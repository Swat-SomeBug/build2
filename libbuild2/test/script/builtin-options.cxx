// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

// Begin prologue.
//
//
// End prologue.

#include <libbuild2/test/script/builtin-options.hxx>

#include <map>
#include <set>
#include <string>
#include <vector>
#include <ostream>
#include <sstream>

namespace build2
{
  namespace test
  {
    namespace script
    {
      namespace cli
      {
        // unknown_option
        //
        unknown_option::
        ~unknown_option () throw ()
        {
        }

        void unknown_option::
        print (::std::ostream& os) const
        {
          os << "unknown option '" << option ().c_str () << "'";
        }

        const char* unknown_option::
        what () const throw ()
        {
          return "unknown option";
        }

        // unknown_argument
        //
        unknown_argument::
        ~unknown_argument () throw ()
        {
        }

        void unknown_argument::
        print (::std::ostream& os) const
        {
          os << "unknown argument '" << argument ().c_str () << "'";
        }

        const char* unknown_argument::
        what () const throw ()
        {
          return "unknown argument";
        }

        // missing_value
        //
        missing_value::
        ~missing_value () throw ()
        {
        }

        void missing_value::
        print (::std::ostream& os) const
        {
          os << "missing value for option '" << option ().c_str () << "'";
        }

        const char* missing_value::
        what () const throw ()
        {
          return "missing option value";
        }

        // invalid_value
        //
        invalid_value::
        ~invalid_value () throw ()
        {
        }

        void invalid_value::
        print (::std::ostream& os) const
        {
          os << "invalid value '" << value ().c_str () << "' for option '"
             << option ().c_str () << "'";

          if (!message ().empty ())
            os << ": " << message ().c_str ();
        }

        const char* invalid_value::
        what () const throw ()
        {
          return "invalid option value";
        }

        // eos_reached
        //
        void eos_reached::
        print (::std::ostream& os) const
        {
          os << what ();
        }

        const char* eos_reached::
        what () const throw ()
        {
          return "end of argument stream reached";
        }

        // scanner
        //
        scanner::
        ~scanner ()
        {
        }

        // argv_scanner
        //
        bool argv_scanner::
        more ()
        {
          return i_ < argc_;
        }

        const char* argv_scanner::
        peek ()
        {
          if (i_ < argc_)
            return argv_[i_];
          else
            throw eos_reached ();
        }

        const char* argv_scanner::
        next ()
        {
          if (i_ < argc_)
          {
            const char* r (argv_[i_]);

            if (erase_)
            {
              for (int i (i_ + 1); i < argc_; ++i)
                argv_[i - 1] = argv_[i];

              --argc_;
              argv_[argc_] = 0;
            }
            else
              ++i_;

            return r;
          }
          else
            throw eos_reached ();
        }

        void argv_scanner::
        skip ()
        {
          if (i_ < argc_)
            ++i_;
          else
            throw eos_reached ();
        }

        // vector_scanner
        //
        bool vector_scanner::
        more ()
        {
          return i_ < v_.size ();
        }

        const char* vector_scanner::
        peek ()
        {
          if (i_ < v_.size ())
            return v_[i_].c_str ();
          else
            throw eos_reached ();
        }

        const char* vector_scanner::
        next ()
        {
          if (i_ < v_.size ())
            return v_[i_++].c_str ();
          else
            throw eos_reached ();
        }

        void vector_scanner::
        skip ()
        {
          if (i_ < v_.size ())
            ++i_;
          else
            throw eos_reached ();
        }

        template <typename X>
        struct parser
        {
          static void
          parse (X& x, bool& xs, scanner& s)
          {
            using namespace std;

            const char* o (s.next ());

            if (s.more ())
            {
              string v (s.next ());
              istringstream is (v);
              if (!(is >> x && is.peek () == istringstream::traits_type::eof ()))
                throw invalid_value (o, v);
            }
            else
              throw missing_value (o);

            xs = true;
          }
        };

        template <>
        struct parser<bool>
        {
          static void
          parse (bool& x, scanner& s)
          {
            s.next ();
            x = true;
          }
        };

        template <>
        struct parser<std::string>
        {
          static void
          parse (std::string& x, bool& xs, scanner& s)
          {
            const char* o (s.next ());

            if (s.more ())
              x = s.next ();
            else
              throw missing_value (o);

            xs = true;
          }
        };

        template <typename X>
        struct parser<std::vector<X> >
        {
          static void
          parse (std::vector<X>& c, bool& xs, scanner& s)
          {
            X x;
            bool dummy;
            parser<X>::parse (x, dummy, s);
            c.push_back (x);
            xs = true;
          }
        };

        template <typename X>
        struct parser<std::set<X> >
        {
          static void
          parse (std::set<X>& c, bool& xs, scanner& s)
          {
            X x;
            bool dummy;
            parser<X>::parse (x, dummy, s);
            c.insert (x);
            xs = true;
          }
        };

        template <typename K, typename V>
        struct parser<std::map<K, V> >
        {
          static void
          parse (std::map<K, V>& m, bool& xs, scanner& s)
          {
            const char* o (s.next ());

            if (s.more ())
            {
              std::string ov (s.next ());
              std::string::size_type p = ov.find ('=');

              K k = K ();
              V v = V ();
              std::string kstr (ov, 0, p);
              std::string vstr (ov, (p != std::string::npos ? p + 1 : ov.size ()));

              int ac (2);
              char* av[] = 
              {
                const_cast<char*> (o), 0
              };

              bool dummy;
              if (!kstr.empty ())
              {
                av[1] = const_cast<char*> (kstr.c_str ());
                argv_scanner s (0, ac, av);
                parser<K>::parse (k, dummy, s);
              }

              if (!vstr.empty ())
              {
                av[1] = const_cast<char*> (vstr.c_str ());
                argv_scanner s (0, ac, av);
                parser<V>::parse (v, dummy, s);
              }

              m[k] = v;
            }
            else
              throw missing_value (o);

            xs = true;
          }
        };

        template <typename X, typename T, T X::*M>
        void
        thunk (X& x, scanner& s)
        {
          parser<T>::parse (x.*M, s);
        }

        template <typename X, typename T, T X::*M, bool X::*S>
        void
        thunk (X& x, scanner& s)
        {
          parser<T>::parse (x.*M, x.*S, s);
        }
      }
    }
  }
}

#include <map>
#include <cstring>

namespace build2
{
  namespace test
  {
    namespace script
    {
      // cleanup_options
      //

      cleanup_options::
      cleanup_options ()
      : no_cleanup_ ()
      {
      }

      typedef
      std::map<std::string, void (*) (cleanup_options&, ::build2::test::script::cli::scanner&)>
      _cli_cleanup_options_map;

      static _cli_cleanup_options_map _cli_cleanup_options_map_;

      struct _cli_cleanup_options_map_init
      {
        _cli_cleanup_options_map_init ()
        {
          _cli_cleanup_options_map_["--no-cleanup"] = 
          &::build2::test::script::cli::thunk< cleanup_options, bool, &cleanup_options::no_cleanup_ >;
        }
      };

      static _cli_cleanup_options_map_init _cli_cleanup_options_map_init_;

      bool cleanup_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_cleanup_options_map::const_iterator i (_cli_cleanup_options_map_.find (o));

        if (i != _cli_cleanup_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      // cat_options
      //

      cat_options::
      cat_options ()
      {
      }

      cat_options::
      cat_options (int& argc,
                   char** argv,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      cat_options::
      cat_options (int start,
                   int& argc,
                   char** argv,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      cat_options::
      cat_options (int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      cat_options::
      cat_options (int start,
                   int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      cat_options::
      cat_options (::build2::test::script::cli::scanner& s,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (cat_options&, ::build2::test::script::cli::scanner&)>
      _cli_cat_options_map;

      static _cli_cat_options_map _cli_cat_options_map_;

      struct _cli_cat_options_map_init
      {
        _cli_cat_options_map_init ()
        {
        }
      };

      static _cli_cat_options_map_init _cli_cat_options_map_init_;

      bool cat_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_cat_options_map::const_iterator i (_cli_cat_options_map_.find (o));

        if (i != _cli_cat_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      bool cat_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // cp_options
      //

      cp_options::
      cp_options ()
      : recursive_ (),
        preserve_ ()
      {
      }

      cp_options::
      cp_options (int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        preserve_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      cp_options::
      cp_options (int start,
                  int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        preserve_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      cp_options::
      cp_options (int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        preserve_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      cp_options::
      cp_options (int start,
                  int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        preserve_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      cp_options::
      cp_options (::build2::test::script::cli::scanner& s,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        preserve_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (cp_options&, ::build2::test::script::cli::scanner&)>
      _cli_cp_options_map;

      static _cli_cp_options_map _cli_cp_options_map_;

      struct _cli_cp_options_map_init
      {
        _cli_cp_options_map_init ()
        {
          _cli_cp_options_map_["--recursive"] = 
          &::build2::test::script::cli::thunk< cp_options, bool, &cp_options::recursive_ >;
          _cli_cp_options_map_["-R"] = 
          &::build2::test::script::cli::thunk< cp_options, bool, &cp_options::recursive_ >;
          _cli_cp_options_map_["-r"] = 
          &::build2::test::script::cli::thunk< cp_options, bool, &cp_options::recursive_ >;
          _cli_cp_options_map_["--preserve"] = 
          &::build2::test::script::cli::thunk< cp_options, bool, &cp_options::preserve_ >;
          _cli_cp_options_map_["-p"] = 
          &::build2::test::script::cli::thunk< cp_options, bool, &cp_options::preserve_ >;
        }
      };

      static _cli_cp_options_map_init _cli_cp_options_map_init_;

      bool cp_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_cp_options_map::const_iterator i (_cli_cp_options_map_.find (o));

        if (i != _cli_cp_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        // cleanup_options base
        //
        if (::build2::test::script::cleanup_options::_parse (o, s))
          return true;

        return false;
      }

      bool cp_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // ln_options
      //

      ln_options::
      ln_options ()
      : symbolic_ ()
      {
      }

      ln_options::
      ln_options (int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : symbolic_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      ln_options::
      ln_options (int start,
                  int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : symbolic_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      ln_options::
      ln_options (int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : symbolic_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      ln_options::
      ln_options (int start,
                  int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : symbolic_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      ln_options::
      ln_options (::build2::test::script::cli::scanner& s,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : symbolic_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (ln_options&, ::build2::test::script::cli::scanner&)>
      _cli_ln_options_map;

      static _cli_ln_options_map _cli_ln_options_map_;

      struct _cli_ln_options_map_init
      {
        _cli_ln_options_map_init ()
        {
          _cli_ln_options_map_["--symbolic"] = 
          &::build2::test::script::cli::thunk< ln_options, bool, &ln_options::symbolic_ >;
          _cli_ln_options_map_["-s"] = 
          &::build2::test::script::cli::thunk< ln_options, bool, &ln_options::symbolic_ >;
        }
      };

      static _cli_ln_options_map_init _cli_ln_options_map_init_;

      bool ln_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_ln_options_map::const_iterator i (_cli_ln_options_map_.find (o));

        if (i != _cli_ln_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        // cleanup_options base
        //
        if (::build2::test::script::cleanup_options::_parse (o, s))
          return true;

        return false;
      }

      bool ln_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // mkdir_options
      //

      mkdir_options::
      mkdir_options ()
      : parents_ ()
      {
      }

      mkdir_options::
      mkdir_options (int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : parents_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      mkdir_options::
      mkdir_options (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : parents_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      mkdir_options::
      mkdir_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : parents_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      mkdir_options::
      mkdir_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : parents_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      mkdir_options::
      mkdir_options (::build2::test::script::cli::scanner& s,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : parents_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (mkdir_options&, ::build2::test::script::cli::scanner&)>
      _cli_mkdir_options_map;

      static _cli_mkdir_options_map _cli_mkdir_options_map_;

      struct _cli_mkdir_options_map_init
      {
        _cli_mkdir_options_map_init ()
        {
          _cli_mkdir_options_map_["--parents"] = 
          &::build2::test::script::cli::thunk< mkdir_options, bool, &mkdir_options::parents_ >;
          _cli_mkdir_options_map_["-p"] = 
          &::build2::test::script::cli::thunk< mkdir_options, bool, &mkdir_options::parents_ >;
        }
      };

      static _cli_mkdir_options_map_init _cli_mkdir_options_map_init_;

      bool mkdir_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_mkdir_options_map::const_iterator i (_cli_mkdir_options_map_.find (o));

        if (i != _cli_mkdir_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        // cleanup_options base
        //
        if (::build2::test::script::cleanup_options::_parse (o, s))
          return true;

        return false;
      }

      bool mkdir_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // mv_options
      //

      mv_options::
      mv_options ()
      : force_ ()
      {
      }

      mv_options::
      mv_options (int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      mv_options::
      mv_options (int start,
                  int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      mv_options::
      mv_options (int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      mv_options::
      mv_options (int start,
                  int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      mv_options::
      mv_options (::build2::test::script::cli::scanner& s,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (mv_options&, ::build2::test::script::cli::scanner&)>
      _cli_mv_options_map;

      static _cli_mv_options_map _cli_mv_options_map_;

      struct _cli_mv_options_map_init
      {
        _cli_mv_options_map_init ()
        {
          _cli_mv_options_map_["--force"] = 
          &::build2::test::script::cli::thunk< mv_options, bool, &mv_options::force_ >;
          _cli_mv_options_map_["-f"] = 
          &::build2::test::script::cli::thunk< mv_options, bool, &mv_options::force_ >;
        }
      };

      static _cli_mv_options_map_init _cli_mv_options_map_init_;

      bool mv_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_mv_options_map::const_iterator i (_cli_mv_options_map_.find (o));

        if (i != _cli_mv_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        // cleanup_options base
        //
        if (::build2::test::script::cleanup_options::_parse (o, s))
          return true;

        return false;
      }

      bool mv_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // rm_options
      //

      rm_options::
      rm_options ()
      : recursive_ (),
        force_ ()
      {
      }

      rm_options::
      rm_options (int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      rm_options::
      rm_options (int start,
                  int& argc,
                  char** argv,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      rm_options::
      rm_options (int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      rm_options::
      rm_options (int start,
                  int& argc,
                  char** argv,
                  int& end,
                  bool erase,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      rm_options::
      rm_options (::build2::test::script::cli::scanner& s,
                  ::build2::test::script::cli::unknown_mode opt,
                  ::build2::test::script::cli::unknown_mode arg)
      : recursive_ (),
        force_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (rm_options&, ::build2::test::script::cli::scanner&)>
      _cli_rm_options_map;

      static _cli_rm_options_map _cli_rm_options_map_;

      struct _cli_rm_options_map_init
      {
        _cli_rm_options_map_init ()
        {
          _cli_rm_options_map_["--recursive"] = 
          &::build2::test::script::cli::thunk< rm_options, bool, &rm_options::recursive_ >;
          _cli_rm_options_map_["-r"] = 
          &::build2::test::script::cli::thunk< rm_options, bool, &rm_options::recursive_ >;
          _cli_rm_options_map_["--force"] = 
          &::build2::test::script::cli::thunk< rm_options, bool, &rm_options::force_ >;
          _cli_rm_options_map_["-f"] = 
          &::build2::test::script::cli::thunk< rm_options, bool, &rm_options::force_ >;
        }
      };

      static _cli_rm_options_map_init _cli_rm_options_map_init_;

      bool rm_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_rm_options_map::const_iterator i (_cli_rm_options_map_.find (o));

        if (i != _cli_rm_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      bool rm_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // rmdir_options
      //

      rmdir_options::
      rmdir_options ()
      : force_ ()
      {
      }

      rmdir_options::
      rmdir_options (int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      rmdir_options::
      rmdir_options (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      rmdir_options::
      rmdir_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      rmdir_options::
      rmdir_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      rmdir_options::
      rmdir_options (::build2::test::script::cli::scanner& s,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : force_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (rmdir_options&, ::build2::test::script::cli::scanner&)>
      _cli_rmdir_options_map;

      static _cli_rmdir_options_map _cli_rmdir_options_map_;

      struct _cli_rmdir_options_map_init
      {
        _cli_rmdir_options_map_init ()
        {
          _cli_rmdir_options_map_["--force"] = 
          &::build2::test::script::cli::thunk< rmdir_options, bool, &rmdir_options::force_ >;
          _cli_rmdir_options_map_["-f"] = 
          &::build2::test::script::cli::thunk< rmdir_options, bool, &rmdir_options::force_ >;
        }
      };

      static _cli_rmdir_options_map_init _cli_rmdir_options_map_init_;

      bool rmdir_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_rmdir_options_map::const_iterator i (_cli_rmdir_options_map_.find (o));

        if (i != _cli_rmdir_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      bool rmdir_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // sed_options
      //

      sed_options::
      sed_options ()
      : quiet_ (),
        in_place_ (),
        expression_ (),
        expression_specified_ (false)
      {
      }

      sed_options::
      sed_options (int& argc,
                   char** argv,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : quiet_ (),
        in_place_ (),
        expression_ (),
        expression_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      sed_options::
      sed_options (int start,
                   int& argc,
                   char** argv,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : quiet_ (),
        in_place_ (),
        expression_ (),
        expression_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      sed_options::
      sed_options (int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : quiet_ (),
        in_place_ (),
        expression_ (),
        expression_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      sed_options::
      sed_options (int start,
                   int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : quiet_ (),
        in_place_ (),
        expression_ (),
        expression_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      sed_options::
      sed_options (::build2::test::script::cli::scanner& s,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : quiet_ (),
        in_place_ (),
        expression_ (),
        expression_specified_ (false)
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (sed_options&, ::build2::test::script::cli::scanner&)>
      _cli_sed_options_map;

      static _cli_sed_options_map _cli_sed_options_map_;

      struct _cli_sed_options_map_init
      {
        _cli_sed_options_map_init ()
        {
          _cli_sed_options_map_["--quiet"] = 
          &::build2::test::script::cli::thunk< sed_options, bool, &sed_options::quiet_ >;
          _cli_sed_options_map_["-n"] = 
          &::build2::test::script::cli::thunk< sed_options, bool, &sed_options::quiet_ >;
          _cli_sed_options_map_["--in-place"] = 
          &::build2::test::script::cli::thunk< sed_options, bool, &sed_options::in_place_ >;
          _cli_sed_options_map_["-i"] = 
          &::build2::test::script::cli::thunk< sed_options, bool, &sed_options::in_place_ >;
          _cli_sed_options_map_["--expression"] = 
          &::build2::test::script::cli::thunk< sed_options, strings, &sed_options::expression_,
            &sed_options::expression_specified_ >;
          _cli_sed_options_map_["-e"] = 
          &::build2::test::script::cli::thunk< sed_options, strings, &sed_options::expression_,
            &sed_options::expression_specified_ >;
        }
      };

      static _cli_sed_options_map_init _cli_sed_options_map_init_;

      bool sed_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_sed_options_map::const_iterator i (_cli_sed_options_map_.find (o));

        if (i != _cli_sed_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      bool sed_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // set_options
      //

      set_options::
      set_options ()
      : exact_ (),
        newline_ (),
        whitespace_ ()
      {
      }

      set_options::
      set_options (int& argc,
                   char** argv,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : exact_ (),
        newline_ (),
        whitespace_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      set_options::
      set_options (int start,
                   int& argc,
                   char** argv,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : exact_ (),
        newline_ (),
        whitespace_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      set_options::
      set_options (int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : exact_ (),
        newline_ (),
        whitespace_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      set_options::
      set_options (int start,
                   int& argc,
                   char** argv,
                   int& end,
                   bool erase,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : exact_ (),
        newline_ (),
        whitespace_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      set_options::
      set_options (::build2::test::script::cli::scanner& s,
                   ::build2::test::script::cli::unknown_mode opt,
                   ::build2::test::script::cli::unknown_mode arg)
      : exact_ (),
        newline_ (),
        whitespace_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (set_options&, ::build2::test::script::cli::scanner&)>
      _cli_set_options_map;

      static _cli_set_options_map _cli_set_options_map_;

      struct _cli_set_options_map_init
      {
        _cli_set_options_map_init ()
        {
          _cli_set_options_map_["--exact"] = 
          &::build2::test::script::cli::thunk< set_options, bool, &set_options::exact_ >;
          _cli_set_options_map_["-e"] = 
          &::build2::test::script::cli::thunk< set_options, bool, &set_options::exact_ >;
          _cli_set_options_map_["--newline"] = 
          &::build2::test::script::cli::thunk< set_options, bool, &set_options::newline_ >;
          _cli_set_options_map_["-n"] = 
          &::build2::test::script::cli::thunk< set_options, bool, &set_options::newline_ >;
          _cli_set_options_map_["--whitespace"] = 
          &::build2::test::script::cli::thunk< set_options, bool, &set_options::whitespace_ >;
          _cli_set_options_map_["-w"] = 
          &::build2::test::script::cli::thunk< set_options, bool, &set_options::whitespace_ >;
        }
      };

      static _cli_set_options_map_init _cli_set_options_map_init_;

      bool set_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_set_options_map::const_iterator i (_cli_set_options_map_.find (o));

        if (i != _cli_set_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      bool set_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // sleep_options
      //

      sleep_options::
      sleep_options ()
      {
      }

      sleep_options::
      sleep_options (int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      sleep_options::
      sleep_options (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      sleep_options::
      sleep_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      sleep_options::
      sleep_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      sleep_options::
      sleep_options (::build2::test::script::cli::scanner& s,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (sleep_options&, ::build2::test::script::cli::scanner&)>
      _cli_sleep_options_map;

      static _cli_sleep_options_map _cli_sleep_options_map_;

      struct _cli_sleep_options_map_init
      {
        _cli_sleep_options_map_init ()
        {
        }
      };

      static _cli_sleep_options_map_init _cli_sleep_options_map_init_;

      bool sleep_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_sleep_options_map::const_iterator i (_cli_sleep_options_map_.find (o));

        if (i != _cli_sleep_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      bool sleep_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // test_options
      //

      test_options::
      test_options ()
      : file_ (),
        directory_ ()
      {
      }

      test_options::
      test_options (int& argc,
                    char** argv,
                    bool erase,
                    ::build2::test::script::cli::unknown_mode opt,
                    ::build2::test::script::cli::unknown_mode arg)
      : file_ (),
        directory_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      test_options::
      test_options (int start,
                    int& argc,
                    char** argv,
                    bool erase,
                    ::build2::test::script::cli::unknown_mode opt,
                    ::build2::test::script::cli::unknown_mode arg)
      : file_ (),
        directory_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      test_options::
      test_options (int& argc,
                    char** argv,
                    int& end,
                    bool erase,
                    ::build2::test::script::cli::unknown_mode opt,
                    ::build2::test::script::cli::unknown_mode arg)
      : file_ (),
        directory_ ()
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      test_options::
      test_options (int start,
                    int& argc,
                    char** argv,
                    int& end,
                    bool erase,
                    ::build2::test::script::cli::unknown_mode opt,
                    ::build2::test::script::cli::unknown_mode arg)
      : file_ (),
        directory_ ()
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      test_options::
      test_options (::build2::test::script::cli::scanner& s,
                    ::build2::test::script::cli::unknown_mode opt,
                    ::build2::test::script::cli::unknown_mode arg)
      : file_ (),
        directory_ ()
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (test_options&, ::build2::test::script::cli::scanner&)>
      _cli_test_options_map;

      static _cli_test_options_map _cli_test_options_map_;

      struct _cli_test_options_map_init
      {
        _cli_test_options_map_init ()
        {
          _cli_test_options_map_["--file"] = 
          &::build2::test::script::cli::thunk< test_options, bool, &test_options::file_ >;
          _cli_test_options_map_["-f"] = 
          &::build2::test::script::cli::thunk< test_options, bool, &test_options::file_ >;
          _cli_test_options_map_["--directory"] = 
          &::build2::test::script::cli::thunk< test_options, bool, &test_options::directory_ >;
          _cli_test_options_map_["-d"] = 
          &::build2::test::script::cli::thunk< test_options, bool, &test_options::directory_ >;
        }
      };

      static _cli_test_options_map_init _cli_test_options_map_init_;

      bool test_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_test_options_map::const_iterator i (_cli_test_options_map_.find (o));

        if (i != _cli_test_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        return false;
      }

      bool test_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }

      // touch_options
      //

      touch_options::
      touch_options ()
      : after_ (),
        after_specified_ (false)
      {
      }

      touch_options::
      touch_options (int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : after_ (),
        after_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
      }

      touch_options::
      touch_options (int start,
                     int& argc,
                     char** argv,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : after_ (),
        after_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
      }

      touch_options::
      touch_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : after_ (),
        after_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      touch_options::
      touch_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : after_ (),
        after_specified_ (false)
      {
        ::build2::test::script::cli::argv_scanner s (start, argc, argv, erase);
        _parse (s, opt, arg);
        end = s.end ();
      }

      touch_options::
      touch_options (::build2::test::script::cli::scanner& s,
                     ::build2::test::script::cli::unknown_mode opt,
                     ::build2::test::script::cli::unknown_mode arg)
      : after_ (),
        after_specified_ (false)
      {
        _parse (s, opt, arg);
      }

      typedef
      std::map<std::string, void (*) (touch_options&, ::build2::test::script::cli::scanner&)>
      _cli_touch_options_map;

      static _cli_touch_options_map _cli_touch_options_map_;

      struct _cli_touch_options_map_init
      {
        _cli_touch_options_map_init ()
        {
          _cli_touch_options_map_["--after"] = 
          &::build2::test::script::cli::thunk< touch_options, string, &touch_options::after_,
            &touch_options::after_specified_ >;
        }
      };

      static _cli_touch_options_map_init _cli_touch_options_map_init_;

      bool touch_options::
      _parse (const char* o, ::build2::test::script::cli::scanner& s)
      {
        _cli_touch_options_map::const_iterator i (_cli_touch_options_map_.find (o));

        if (i != _cli_touch_options_map_.end ())
        {
          (*(i->second)) (*this, s);
          return true;
        }

        // cleanup_options base
        //
        if (::build2::test::script::cleanup_options::_parse (o, s))
          return true;

        return false;
      }

      bool touch_options::
      _parse (::build2::test::script::cli::scanner& s,
              ::build2::test::script::cli::unknown_mode opt_mode,
              ::build2::test::script::cli::unknown_mode arg_mode)
      {
        // Can't skip combined flags (--no-combined-flags).
        //
        assert (opt_mode != ::build2::test::script::cli::unknown_mode::skip);

        bool r = false;
        bool opt = true;

        while (s.more ())
        {
          const char* o = s.peek ();

          if (std::strcmp (o, "--") == 0)
          {
            opt = false;
            s.skip ();
            r = true;
            continue;
          }

          if (opt)
          {
            if (_parse (o, s))
            {
              r = true;
              continue;
            }

            if (std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
            {
              // Handle combined option values.
              //
              std::string co;
              if (const char* v = std::strchr (o, '='))
              {
                co.assign (o, 0, v - o);
                ++v;

                int ac (2);
                char* av[] =
                {
                  const_cast<char*> (co.c_str ()),
                  const_cast<char*> (v)
                };

                ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                if (_parse (co.c_str (), ns))
                {
                  // Parsed the option but not its value?
                  //
                  if (ns.end () != 2)
                    throw ::build2::test::script::cli::invalid_value (co, v);

                  s.next ();
                  r = true;
                  continue;
                }
                else
                {
                  // Set the unknown option and fall through.
                  //
                  o = co.c_str ();
                }
              }

              // Handle combined flags.
              //
              char cf[3];
              {
                const char* p = o + 1;
                for (; *p != '\0'; ++p)
                {
                  if (!((*p >= 'a' && *p <= 'z') ||
                        (*p >= 'A' && *p <= 'Z') ||
                        (*p >= '0' && *p <= '9')))
                    break;
                }

                if (*p == '\0')
                {
                  for (p = o + 1; *p != '\0'; ++p)
                  {
                    std::strcpy (cf, "-");
                    cf[1] = *p;
                    cf[2] = '\0';

                    int ac (1);
                    char* av[] = 
                    {
                      cf
                    };

                    ::build2::test::script::cli::argv_scanner ns (0, ac, av);

                    if (!_parse (cf, ns))
                      break;
                  }

                  if (*p == '\0')
                  {
                    // All handled.
                    //
                    s.next ();
                    r = true;
                    continue;
                  }
                  else
                  {
                    // Set the unknown option and fall through.
                    //
                    o = cf;
                  }
                }
              }

              switch (opt_mode)
              {
                case ::build2::test::script::cli::unknown_mode::skip:
                {
                  s.skip ();
                  r = true;
                  continue;
                }
                case ::build2::test::script::cli::unknown_mode::stop:
                {
                  break;
                }
                case ::build2::test::script::cli::unknown_mode::fail:
                {
                  throw ::build2::test::script::cli::unknown_option (o);
                }
              }

              break;
            }
          }

          switch (arg_mode)
          {
            case ::build2::test::script::cli::unknown_mode::skip:
            {
              s.skip ();
              r = true;
              continue;
            }
            case ::build2::test::script::cli::unknown_mode::stop:
            {
              break;
            }
            case ::build2::test::script::cli::unknown_mode::fail:
            {
              throw ::build2::test::script::cli::unknown_argument (o);
            }
          }

          break;
        }

        return r;
      }
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

