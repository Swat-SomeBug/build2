// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

#ifndef LIBBUILD2_TEST_SCRIPT_BUILTIN_OPTIONS_HXX
#define LIBBUILD2_TEST_SCRIPT_BUILTIN_OPTIONS_HXX

// Begin prologue.
//
//
// End prologue.

#include <vector>
#include <iosfwd>
#include <string>
#include <cstddef>
#include <exception>

#ifndef CLI_POTENTIALLY_UNUSED
#  if defined(_MSC_VER) || defined(__xlC__)
#    define CLI_POTENTIALLY_UNUSED(x) (void*)&x
#  else
#    define CLI_POTENTIALLY_UNUSED(x) (void)x
#  endif
#endif

namespace build2
{
  namespace test
  {
    namespace script
    {
      namespace cli
      {
        class unknown_mode
        {
          public:
          enum value
          {
            skip,
            stop,
            fail
          };

          unknown_mode (value);

          operator value () const 
          {
            return v_;
          }

          private:
          value v_;
        };

        // Exceptions.
        //

        class exception: public std::exception
        {
          public:
          virtual void
          print (::std::ostream&) const = 0;
        };

        ::std::ostream&
        operator<< (::std::ostream&, const exception&);

        class unknown_option: public exception
        {
          public:
          virtual
          ~unknown_option () throw ();

          unknown_option (const std::string& option);

          const std::string&
          option () const;

          virtual void
          print (::std::ostream&) const;

          virtual const char*
          what () const throw ();

          private:
          std::string option_;
        };

        class unknown_argument: public exception
        {
          public:
          virtual
          ~unknown_argument () throw ();

          unknown_argument (const std::string& argument);

          const std::string&
          argument () const;

          virtual void
          print (::std::ostream&) const;

          virtual const char*
          what () const throw ();

          private:
          std::string argument_;
        };

        class missing_value: public exception
        {
          public:
          virtual
          ~missing_value () throw ();

          missing_value (const std::string& option);

          const std::string&
          option () const;

          virtual void
          print (::std::ostream&) const;

          virtual const char*
          what () const throw ();

          private:
          std::string option_;
        };

        class invalid_value: public exception
        {
          public:
          virtual
          ~invalid_value () throw ();

          invalid_value (const std::string& option,
                         const std::string& value,
                         const std::string& message = std::string ());

          const std::string&
          option () const;

          const std::string&
          value () const;

          const std::string&
          message () const;

          virtual void
          print (::std::ostream&) const;

          virtual const char*
          what () const throw ();

          private:
          std::string option_;
          std::string value_;
          std::string message_;
        };

        class eos_reached: public exception
        {
          public:
          virtual void
          print (::std::ostream&) const;

          virtual const char*
          what () const throw ();
        };

        // Command line argument scanner interface.
        //
        // The values returned by next() are guaranteed to be valid
        // for the two previous arguments up until a call to a third
        // peek() or next().
        //
        class scanner
        {
          public:
          virtual
          ~scanner ();

          virtual bool
          more () = 0;

          virtual const char*
          peek () = 0;

          virtual const char*
          next () = 0;

          virtual void
          skip () = 0;
        };

        class argv_scanner: public scanner
        {
          public:
          argv_scanner (int& argc, char** argv, bool erase = false);
          argv_scanner (int start, int& argc, char** argv, bool erase = false);

          int
          end () const;

          virtual bool
          more ();

          virtual const char*
          peek ();

          virtual const char*
          next ();

          virtual void
          skip ();

          private:
          int i_;
          int& argc_;
          char** argv_;
          bool erase_;
        };

        class vector_scanner: public scanner
        {
          public:
          vector_scanner (const std::vector<std::string>&, std::size_t start = 0);

          std::size_t
          end () const;

          void
          reset (std::size_t start = 0);

          virtual bool
          more ();

          virtual const char*
          peek ();

          virtual const char*
          next ();

          virtual void
          skip ();

          private:
          const std::vector<std::string>& v_;
          std::size_t i_;
        };

        template <typename X>
        struct parser;
      }
    }
  }
}

#include <libbuild2/types.hxx>

namespace build2
{
  namespace test
  {
    namespace script
    {
      class cleanup_options
      {
        public:
        // Option accessors.
        //
        const bool&
        no_cleanup () const;

        // Implementation details.
        //
        protected:
        cleanup_options ();

        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        public:
        bool no_cleanup_;
      };

      class cat_options
      {
        public:
        cat_options ();

        cat_options (int& argc,
                     char** argv,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cat_options (int start,
                     int& argc,
                     char** argv,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cat_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cat_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cat_options (::build2::test::script::cli::scanner&,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
      };

      class cp_options: public ::build2::test::script::cleanup_options
      {
        public:
        cp_options ();

        cp_options (int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cp_options (int start,
                    int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cp_options (int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cp_options (int start,
                    int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        cp_options (::build2::test::script::cli::scanner&,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        recursive () const;

        const bool&
        preserve () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool recursive_;
        bool preserve_;
      };

      class ln_options: public ::build2::test::script::cleanup_options
      {
        public:
        ln_options ();

        ln_options (int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        ln_options (int start,
                    int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        ln_options (int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        ln_options (int start,
                    int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        ln_options (::build2::test::script::cli::scanner&,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        symbolic () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool symbolic_;
      };

      class mkdir_options: public ::build2::test::script::cleanup_options
      {
        public:
        mkdir_options ();

        mkdir_options (int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mkdir_options (int start,
                       int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mkdir_options (int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mkdir_options (int start,
                       int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mkdir_options (::build2::test::script::cli::scanner&,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        parents () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool parents_;
      };

      class mv_options: public ::build2::test::script::cleanup_options
      {
        public:
        mv_options ();

        mv_options (int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mv_options (int start,
                    int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mv_options (int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mv_options (int start,
                    int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        mv_options (::build2::test::script::cli::scanner&,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        force () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool force_;
      };

      class rm_options
      {
        public:
        rm_options ();

        rm_options (int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rm_options (int start,
                    int& argc,
                    char** argv,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rm_options (int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rm_options (int start,
                    int& argc,
                    char** argv,
                    int& end,
                    bool erase = false,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rm_options (::build2::test::script::cli::scanner&,
                    ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                    ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        recursive () const;

        const bool&
        force () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool recursive_;
        bool force_;
      };

      class rmdir_options
      {
        public:
        rmdir_options ();

        rmdir_options (int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rmdir_options (int start,
                       int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rmdir_options (int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rmdir_options (int start,
                       int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        rmdir_options (::build2::test::script::cli::scanner&,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        force () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool force_;
      };

      class sed_options
      {
        public:
        sed_options ();

        sed_options (int& argc,
                     char** argv,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sed_options (int start,
                     int& argc,
                     char** argv,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sed_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sed_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sed_options (::build2::test::script::cli::scanner&,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        quiet () const;

        const bool&
        in_place () const;

        const strings&
        expression () const;

        bool
        expression_specified () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool quiet_;
        bool in_place_;
        strings expression_;
        bool expression_specified_;
      };

      class set_options
      {
        public:
        set_options ();

        set_options (int& argc,
                     char** argv,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        set_options (int start,
                     int& argc,
                     char** argv,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        set_options (int& argc,
                     char** argv,
                     int& end,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        set_options (int start,
                     int& argc,
                     char** argv,
                     int& end,
                     bool erase = false,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        set_options (::build2::test::script::cli::scanner&,
                     ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                     ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        exact () const;

        const bool&
        newline () const;

        const bool&
        whitespace () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool exact_;
        bool newline_;
        bool whitespace_;
      };

      class sleep_options
      {
        public:
        sleep_options ();

        sleep_options (int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sleep_options (int start,
                       int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sleep_options (int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sleep_options (int start,
                       int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        sleep_options (::build2::test::script::cli::scanner&,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
      };

      class test_options
      {
        public:
        test_options ();

        test_options (int& argc,
                      char** argv,
                      bool erase = false,
                      ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                      ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        test_options (int start,
                      int& argc,
                      char** argv,
                      bool erase = false,
                      ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                      ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        test_options (int& argc,
                      char** argv,
                      int& end,
                      bool erase = false,
                      ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                      ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        test_options (int start,
                      int& argc,
                      char** argv,
                      int& end,
                      bool erase = false,
                      ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                      ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        test_options (::build2::test::script::cli::scanner&,
                      ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                      ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const bool&
        file () const;

        const bool&
        directory () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        bool file_;
        bool directory_;
      };

      class touch_options: public ::build2::test::script::cleanup_options
      {
        public:
        touch_options ();

        touch_options (int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        touch_options (int start,
                       int& argc,
                       char** argv,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        touch_options (int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        touch_options (int start,
                       int& argc,
                       char** argv,
                       int& end,
                       bool erase = false,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        touch_options (::build2::test::script::cli::scanner&,
                       ::build2::test::script::cli::unknown_mode option = ::build2::test::script::cli::unknown_mode::fail,
                       ::build2::test::script::cli::unknown_mode argument = ::build2::test::script::cli::unknown_mode::stop);

        // Option accessors.
        //
        const string&
        after () const;

        bool
        after_specified () const;

        // Implementation details.
        //
        protected:
        bool
        _parse (const char*, ::build2::test::script::cli::scanner&);

        private:
        bool
        _parse (::build2::test::script::cli::scanner&,
                ::build2::test::script::cli::unknown_mode option,
                ::build2::test::script::cli::unknown_mode argument);

        public:
        string after_;
        bool after_specified_;
      };
    }
  }
}

#include <libbuild2/test/script/builtin-options.ixx>

// Begin epilogue.
//
//
// End epilogue.

#endif // LIBBUILD2_TEST_SCRIPT_BUILTIN_OPTIONS_HXX
