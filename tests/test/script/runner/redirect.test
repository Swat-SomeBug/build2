# file      : tests/test/script/runner/redirect.test
# copyright : Copyright (c) 2014-2016 Code Synthesis Ltd
# license   : MIT; see accompanying LICENSE file

.include ../common.test

b += --no-column

# null-redirect tests.
#
: out-null
:
$c <'$* -o foo >-';
$b

: err-null
:
$c <'$* -e foo 2>-';
$b

# Here-string tests.
#
: in-str
:
$c <'$* -i 0 <foo';
$b

: out-str
:
$c <'$* -o foo >foo';
$b

: err-str
:
$c <'$* -e foo 2>foo';
$b

: inout-str
:
$c <'$* -i 1 <foo >foo';
$b

: inout-str-fail
:
$c <'$* -i 1 <foo >bar';
$b 2>>~%EOE% != 0
%.{3}
-bar
+foo
%testscript:1: error: \.\.[/\\]\.\.[/\\]\.\.[/\\]driver(\.exe)? stdout doesn't match the expected output%
%  info: stdout: test[/\\]1[/\\]stdout%
%  info: expected stdout: test[/\\]1[/\\]stdout\.orig%
%  info: stdin: test[/\\]1[/\\]stdin%
EOE

: inerr-str
:
$c <'$* -i 2 <foo 2>foo';
$b

: inout-err-str
:
$c <'$* -i 1 -e bar <foo 1>foo 2>bar';
$b

# Here-document tests.
#
: in-doc
:
$c <<EOI;
$* -i 0 <<EOO
foo
bar
EOO
EOI
$b

: out-doc
:
$c <<EOI;
$* -o foo -o bar >>EOO
foo
bar
EOO
EOI
$b

: err-doc
:
$c <<EOI;
$* -e foo -e bar 2>>EOO
foo
bar
EOO
EOI
$b

: inout-doc
:
$c <<EOI;
$* -i 1 <<EOF >>EOO
foo
bar
EOF
foo
bar
EOO
EOI
$b

: inerr-doc
:
$c <<EOI;
$* -i 2 <<EOF 2>>EOE
foo
bar
EOF
foo
bar
EOE
EOI
$b

: empty-str-doc
:
$c <<EOI;
$* -i 1 -e "" <<EOF >>EOO 2>""
EOF
EOO
EOI
$b

: nl-containing-doc
:
$c <<EOI;
$* -i 1 <<EOF >>EOO

EOF

EOO
EOI
$b

# No-newline tests.
#
: no-newline-str
:
$c <'$* -i 1 <:"foo" >:"foo"';
$b

: no-newline-empty-str
:
$c <'$* -i 1 <:"" >:""';
$b

: no-newline-str-fail1
:
$c <'$* -i 1 <:"foo" >"foo"';
$b 2>>~/EOE/ != 0
/.{3}
-foo
+foo
\ No newline at end of file
/testscript:1: error: .+driver(\.exe)? stdout doesn't match the expected output/
/.{3}
EOE

: no-newline-str-fail2
:
$c <'$* -i 1 <"foo" >:"foo"';
$b 2>>~/EOE/ != 0
/.{3}
-foo
\ No newline at end of file
+foo
/testscript:1: error: .+driver(\.exe)? stdout doesn't match the expected output/
/.{3}
EOE

: no-newline-doc
:
$c <<EOI;
$* -i 1 <<:EOF >>:EOO
foo
EOF
foo
EOO
EOI
$b

: no-newline-doc-fail1
:
$c <<EOI;
$* -i 1 <<:EOF >>EOO
foo
EOF
foo
EOO
EOI
$b 2>>~/EOE/ != 0
/.{3}
-foo
+foo
\ No newline at end of file
/testscript:1: error: .+driver(\.exe)? stdout doesn't match the expected output/
/.{3}
EOE

: no-newline-doc-fail2
:
$c <<EOI;
$* -i 1 <<EOF >>:EOO
foo
EOF
foo
EOO
EOI
$b 2>>~/EOE/ != 0
/.{3}
-foo
\ No newline at end of file
+foo
/testscript:1: error: .+driver(\.exe)? stdout doesn't match the expected output/
/.{3}
EOE

: no-newline-empty-str-doc
:
$c <<EOI;
$* -i 1 <<:EOF >>:EOO 2>:""
EOF
EOO
EOI
$b

: no-newline-nl-cont-doc
:
$c <<EOI;
$* -i 1 <<:EOF >>:EOO

EOF

EOO
EOI
$b

# Merge tests.
#
: merge-str
:
$c <<EOI;
$* -o foo -e bar 2>>EOE 1>&2
foo
bar
EOE
EOI
$b

: merge-doc
:
$c <<EOI;
$* -i 1 <<EOF -e baz >>EOO 2>&1
foo
bar
EOF
foo
bar
baz
EOO
EOI
$b

# File tests.
#
: file
:
$c <<EOI;
$* -o foo >>>out;
$* -e bar 2>>>&out;
$* -i 1 <<<out >>EOO
foo
bar
EOO
EOI
$b

: merge-file
:
$c <<EOI;
$* -o foo -e bar 2>&1 >>>out;
$* -e baz -o biz 1>&2 2>>>&out;
$* -i 1 <<<out >>EOO
foo
bar
baz
biz
EOO
EOI
$b

# Regex tests.
#
: out-str-regex
:
{
  : match
  :
  $c <'$* -o foo >~/Foo?/i';
  $b

  : fail
  :
  $c <'$* -o fooo >~/Foo?/i';
  $b 2>>~%EOE% != 0
  %testscript:1: error: \.\.[/\\]\.\.[/\\]\.\.[/\\]\.\.[/\\]driver(\.exe)? stdout doesn't match the regex%
  %  info: stdout: test[/\\]1[/\\]stdout%
  %  info: stdout regex: test[/\\]1[/\\]stdout\.regex%
  EOE
}

: out-doc-regex
:
{
  : match
  :
  $c <<EOI;
  $* -o foo -o foo -o bar >>~/EOO/i
  /FO*/*
  bar
  /*
  EOO
  EOI
  $b

  : match-empty
  :
  $c <<EOI;
  $* >>:~/EOO/i
  /.{0}
  EOO
  EOI
  $b
}

# Builtins redirects.
#
# @@ That will probably become redundant when builtins and process obtain file
#    descriptors uniformly.
#
: builtins
:
{
  : out-null
  :
  $c <'echo "abc" >-';
  $b

  : err-null
  :
  $c <'echo "abc" 1>&2 2>-';
  $b

  : in-str
  :
  $c <'echo <foo 1>-';
  $b

  : out-str
  :
  $c <'echo "foo" >foo';
  $b

  : err-str
  :
  $c <'echo "foo" 2>foo 1>&2';
  $b

  : inout-str
  :
  $c <'cat <foo >foo';
  $b

  : inerr-str
  :
  $c <'cat <foo 2>foo 1>&2';
  $b
}
