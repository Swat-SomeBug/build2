# file      : tests/cc/modules/testscript
# copyright : Copyright (c) 2014-2017 Code Synthesis Ltd
# license   : MIT; see accompanying LICENSE file

crosstest = false
test.arguments = config.cxx="$recall($cxx.path)"

.include ../../common.test

+cat <<EOI >+build/bootstrap.build
using test
EOI

+cat <<EOI >=build/root.build
cxx.std = experimental

# Force modules.
#
cxx.features.modules = true

using cxx

# We forced modules but for VC we need at least 15u3 (19.11). So "unforce"
# them in this case.
#
if ($cxx.id == 'msvc' && $cxx.version.major == 19 && $cxx.version.minor < 11)
  cxx.features.modules = false

hxx{*}: extension = hxx
mxx{*}: extension = mxx
cxx{*}: extension = cxx

if ($cxx.target.class == 'windows')
  bmis{*}: cxx.poptions += '-DLIBFOO_EXPORT=__declspec(dllexport)'

exe{*}: test = true
EOI

# Determine if we have module support.
#
+$* noop <<EOI | set modules
print $cxx.features.modules
EOI

: enabled
:
if $modules
{

# Common source files that are symlinked (@@ TODO: ln builtin) in the
# test directories if used.
#
+cat <<EOI >=core.mxx
#ifndef LIBFOO_EXPORT
#  define LIBFOO_EXPORT
#endif

#if __cpp_modules >= 201704
export
#endif
module foo.core;

export LIBFOO_EXPORT int f (int);
EOI

+cat <<EOI >=core.cxx
module foo.core;
int f (int i) {return i - 1;}
EOI

+cat <<EOI >=driver.cxx
import foo.core;
int main (int argc, char*[]) {return f (argc);}
EOI

: bmi-combined
:
: Test combined interface/implementation unit specified as bmi{}.
:
cp ../core.mxx ./ && cat >+core.mxx <<EOI;
  int f (int i) {return i - 1;}
  EOI
cp ../driver.cxx ./;
$* test clean <<EOI
  exe{test}: cxx{driver} bmi{core}
  bmi{core}: mxx{core}
  EOI

: mxx-combined
:
: Test combined interface/implementation unit specified as mxx{}.
:
cp ../core.mxx ./ && cat >+core.mxx <<EOI;
  int f (int i) {return i - 1;}
  EOI
cp ../driver.cxx ./;
$* test clean <<EOI
  exe{test}: cxx{driver} mxx{core}
  EOI

: bmi-separate
:
: Test separate interface/implementation unit specified as bmi{}.
:
cp ../core.mxx ../core.cxx ../driver.cxx ./;
$* test clean <<EOI
  exe{test}: cxx{driver} {bmi cxx}{core}
  bmi{core}: mxx{core}
  EOI

: mxx-separate
:
: Test separate interface/implementation unit specified as mxx{}.
:
cp ../core.mxx ../core.cxx ../driver.cxx ./;
$* test clean <<EOI
  exe{test}: cxx{driver} {mxx cxx}{core}
  EOI

: name-match
:
: Test fuzzy match between module name and file name
:
{
  # "Bad" match which we should better.
  #
  +cat <<EOI >=core.mxx
    #if __cpp_modules >= 201704
    export
    #endif
    module bar.core;
    EOI

  : separator
  :
  : Test separator equivalence.
  :
  cp ../../core.mxx foo-core.mxx;
  cp ../core.mxx ../../core.cxx ../../driver.cxx ./;
  $* test clean <'exe{test}: cxx{driver core} mxx{core foo-core}'

  : case
  :
  : Test case-insensitivity and case-change as a separator.
  :
  cp ../../core.mxx FooCore.mxx;
  cp ../core.mxx ../../core.cxx ../../driver.cxx ./;
  $* test clean <'exe{test}: cxx{driver core} mxx{core FooCore}'

  : dir
  :
  : Test subdirectory.
  :
  mkdir foo;
  cp ../../core.mxx foo/core.mxx;
  cp ../core.mxx ../../core.cxx ../../driver.cxx ./;
  $* test clean <'exe{test}: cxx{driver core} mxx{core} foo/mxx{core}'
}

: unresolved
:
cp ../driver.cxx ./;
$* test &*.d <'exe{test}: cxx{driver}' 2>>EOE != 0
  error: unresolved import for module foo.core
  EOE

: misguessed
:
cp ../core.mxx ./;
cat <'import bar.core;' >=driver.cxx;
$* test &*.d <'exe{test}: cxx{driver} mxx{core}' 2>>EOE != 0
  error: failed to correctly guess module name from mxx{core}
    info: guessed: bar.core
    info: actual:  foo.core
    info: consider adjusting module interface file names or
    info: consider explicitly specifying module name with @@ MOD
  EOE

: library
:
: Test importing a module from a library.
:
cp ../core.mxx ../core.cxx ../driver.cxx ./;
$* test clean <<EOI
  exe{test}: cxx{driver} lib{foo}
  lib{foo}: {mxx cxx}{core}
  EOI

: re-export
:
: Test module re-exporting (export import M;)
:
if ($cxx.id.type != "clang")
{
  +cat <<EOI >=base.mxx
    #if __cpp_modules >= 201704
    export
    #endif
    module foo.base;

    export import foo.core;
    EOI

  +cat <<EOI >=extra.mxx
    #ifndef LIBFOO_EXPORT
    #  define LIBFOO_EXPORT
    #endif

    #if __cpp_modules >= 201704
    export
    #endif
    module foo.extra;

    export
    {
      import foo.base;

      // VC appears to require dll-export of inline functions.
      //
      LIBFOO_EXPORT inline int g (int i) {return i != 0 ? i : -1;}
    }
    EOI

  +cat <<EOI >=foo.mxx
    #if __cpp_modules >= 201704
    export
    #endif
    module foo;

    export
    {
      import foo.core;
      import foo.base;
      import foo.extra;
    }
    EOI

  : basic
  :
  cp ../base.mxx ../../core.mxx ../../core.cxx ./;
  cat <<EOI >=driver.cxx;
    import foo.base;
    int main (int argc, char*[]) {return f (argc);}
    EOI
  $* test clean <'exe{test}: cxx{driver core} mxx{core base}'

  : recursive
  :
  cp ../base.mxx ../extra.mxx ../../core.mxx ../../core.cxx ./;
  cat <<EOI >=driver.cxx;
    import foo.extra;
    int main (int argc, char*[]) {return f (g (argc));}
    EOI
  $* test clean <'exe{test}: cxx{driver core} mxx{core base extra}'

  : duplicate
  :
  cp ../base.mxx ../extra.mxx ../foo.mxx ../../core.mxx ../../core.cxx ./;
  cat <<EOI >=driver.cxx;
    import foo;
    int main (int argc, char*[]) {return f (g (argc));}
    EOI
  $* test clean <'exe{test}: cxx{driver core} mxx{core base extra foo}'

  : library
  :
  cp ../base.mxx ../extra.mxx ../foo.mxx ../../core.mxx ../../core.cxx ./;
  cat <<EOI >=driver.cxx;
    import foo;
    int main (int argc, char*[]) {return f (g (argc));}
    EOI
  $* test clean <<EOI
    exe{test}: cxx{driver} mxx{foo} lib{foo}
    lib{foo}: mxx{core base extra} cxx{core}
    EOI
}

}
