# file      : tests/name/pattern.test
# copyright : Copyright (c) 2014-2017 Code Synthesis Ltd
# license   : MIT; see accompanying LICENSE file

.include ../common.test

+cat <<EOI >=build/root.build
define txt: file
txt{*}: extension = txt
EOI

$* <'print p%*.txt'       >'p%*.txt'       : project-simple
$* <'print p%{*.txt -x*}' >'p%*.txt p%-x*' : project-group

$* <"print '*.txt'" >'*.txt' : quoted-single
$* <'print "*.txt"' >'*.txt' : quoted-double
$* <<EOI            >'*.txt' : quoted-expansion
pat = '*'
print "$(pat).txt"
EOI

: detect
:
: Test pattern_mode parsing logic.
{
  : second-pattern
  :
  touch foo.txt;
  $* <'print {foo *.txt}' >'foo foo.txt'

  : second-inclusion
  :
  touch foo.txt bar.txt;
  $* <'print {f*.txt +b*.txt}' >'foo.txt bar.txt'
}

: diagnostics
:
{
  : simple
  :
  $* <'print {*.txt file{foo}}' 2>>EOE != 0
  <stdin>:1:8: error: invalid 'file{foo}' in name pattern
  EOE

  : inclusion-exclusion-sign
  :
  $* <'print {*.txt foo}' 2>>EOE != 0
  <stdin>:1:8: error: missing leading +/- in 'foo' name pattern
  EOE

  : empty-inclusion-exclusion
  :
  $* <'print {*.txt -}' 2>>EOE != 0
  <stdin>:1:8: error: empty name pattern
  EOE

  : inconsistent-result
  :
  $* <'print {*.txt +foo/}' 2>>EOE != 0
  <stdin>:1:8: error: inconsistent file/directory result in name pattern
  EOE
}

: basics
:
{
  touch foo.txt;
  $* <'print *.txt' >'foo.txt'                   : simple-file

  mkdir foo;
  $* <'print */' >/'foo/'                        : simple-dir

  touch foo.txt;
  $* <'print {*.txt}' >'foo.txt'                 : group

  mkdir dir && touch dir/foo.txt;
  $* <'print dir/{*.txt}' >'dir/foo.txt'         : dir

  touch foo.txt;
  $* <'print file{*.txt}' >'file{foo.txt}'       : type

  touch foo.txt;
  $* <'print x@{*.txt}' >'x@foo.txt'             : pair

  touch bar.txt;
  $* <'print x@dir/file{f*.txt}' >''             : empty

  mkdir dir && touch dir/foo.txt;
  $* <'print **.txt' >/'dir/foo.txt'             : recursive

  mkdir dir && touch dir/foo.txt;
  $* <'print d*/*.txt' >/'dir/foo.txt'           : multi-pattern

  touch foo.txt bar.txt;
  $* <'print {*.txt -bar.txt}' >'foo.txt'        : exclude-match

  touch foo.txt bar.txt;
  $* <'print {*.txt -b*.txt}' >'foo.txt'         : exclude-pattern

  touch bar.txt;
  $* <'print {f*.txt +bar.txt}' >'bar.txt'       : include-match

  touch bar.txt;
  $* <'print {f*.txt +b*.txt}' >'bar.txt'        : include-pattern

  touch foo.txt fox.txt;
  $* <'print {*.txt -f*.txt +*x.txt}' >'fox.txt' : include-exclude-order
}

: target-type
:
: Test target type-specific pattern amendment logic.
{
  : append-extension
  :
  touch foo.txt bar.txt;
  $* <'print txt{* -bar}' >'txt{foo}'

  : existing-extension
  :
  touch foo.txt bar.txt;
  $* <'print txt{*.txt -bar.txt}' >'txt{foo.txt}'

  : append-slash
  :
  mkdir foo bar;
  $* <'print dir{* -bar}' >/'dir{foo/}'

  : existing-slash
  :
  mkdir foo bar;
  $* <'print dir{*/ -bar/}' >/'dir{foo/}'
}

: dot
:
: Test filtering of hidden files/directories.
{
  touch foo.txt .foo.txt;
  $* <'print *.txt' >'foo.txt'                       : file-excl

  touch foo.txt .foo.txt;
  $* <'print .*.txt' >'.foo.txt'                     : file-incl

  mkdir dir .dir;
  $* <'print */' >/'dir/'                            : dir-excl

  mkdir dir .dir;
  $* <'print .*/' >/'.dir/'                          : dir-incl

  mkdir dir .dir && touch dir/foo.txt .dir/foo.txt;
  $* <'print */*.txt' >/'dir/foo.txt';
  $* <'print **.txt'  >/'dir/foo.txt'                : dir-interm-excl

  mkdir dir .dir && touch dir/foo.txt .dir/foo.txt;
  $* <'print .*/*.txt' >/'.dir/foo.txt'              : dir-interm-incl
}

: expansion
:
: Test interaction with expansion/concatenation/re-parse.
{
  # Do we want to recognize patterns in non-concatenating expansion?
  #
  # pat = '*.txt'
  # print $pat
  #
  # While this case is probably better rewritten as (i.e., move pattern search
  # to variable assignment):
  #
  # pat = *.txt
  # print $pat
  #
  # One may also want to do something like this:
  #
  # pat = '*.txt'
  # print dir1/{$pat}
  # print dir2/{$pat}
  #
  # Note that if we make it work, escaping this case will be pretty hairy:
  #
  # filters = --include '*.txt' --exclude '*.obj'
  # options += $filters

  #: pattern-via-expansion
  #:
  #$* <<EOI >'<*.txt>'
  #pat = '*.txt'
  #print $pat
  #EOI

  #: pattern-via-expansion-list
  #:
  #$* <<EOI >'<*.hxx+*.txt>'
  #pats = '*.hxx' '+*.txt'
  #print {$pats}
  #EOI

  #: pattern-via-expansion-type
  #:
  #$* <<EOI >'<*.txt>'
  #pat = '*.txt'
  #print txt{$pat}
  #EOI

  #: pattern-via-expansion-dir
  #:
  #$* <<EOI >'<*.txt>'
  #pat = '*.txt'
  #print dir/{$pat}
  #EOI

  : pattern-via-concat
  :
  touch foo.txt;
  $* <<EOI >'foo.txt'
    ext = txt
    print *.$ext
    EOI

  : pattern-via-concat-expansion
  :
  touch foo.txt;
  $* <<EOI >'foo.txt'
    pat = 'f*'
    ext = txt
    print $pat.$ext
    EOI
}

: command-line
:
: Test pattern expansion on the command line.
{
  : variable
  :
  {
    mkdir dir;
    $* <'print $d' 'd=*/' >/'dir/'          : dir

    mkdir dir;
    $* <'print $d' 'd=dir{*}' >/'dir{dir/}' : dir-type

    touch foo.txt;
    $* <'print $f' 'f=*.txt' >'foo.txt'     : feil
  }

  : buildspec
  :
  {
    test.arguments =
    test.options += --buildfile buildfile

    mkdir dir && cat <'./:' >=dir/buildfile;
    $* '*/'                                        : dir

    mkdir dir dir1 && cat <'./:' >=dir/buildfile;
    $* 'update(dir{* -dir1})'                      : dir-type
  }
}
