Version 0.3.0

  * Support for High Fidelity Builds (HFB).

    The C++ compile and link rules now detect when the compiler, options, or
    input file set have changed and trigger the update of the target. Some
    examples of the events that would now trigger an automatic update are:

    * compiler change (e.g., g++ to clang++), upgrade, or reconfiguration
    * change of compile/link options (e.g., -O2 to -O3)
    * replacement of a source file (e.g., foo.cpp with foo.cxx)
    * removal of a file from a library/executable

  * New command line variable override semantics. A command line variable can
    be an override (=), prefix (=+), or suffix (+=), for example:

    b config.cxx=clang++ config.cxx.coptions+=-g config.cxx.poptions=+-I/tmp

    Prefixes/suffixes are applied at the outsets of values set in buildfiles,
    provided these values were set (in those buildfiles) using =+/+= and not
    an expansion, for example:

    b x=+P x+=S

    x = y
    print $x # P y S

    x =+ p
    x += s
    print $x # P p y s S

    But:

    x = A $x B
    print $x # A P p y s S B

    By default an override applies to all the projects mentioned in the
    buildspec as well as to their subprojects. We can restrict an override to
    not apply to subprojects by prefixing it with '%', for example:

    b %config.cxx=clang++ configure

    An override can also be made global (i.e., it applies to all projects,
    including the imported ones) by prefixing it with '!'. As an example,
    compare these two command lines:

    b config.cxx.coptions+=-g
    b '!config.cxx.coptions+=-g'

    In the first case only the current project and its subprojects will be
    recompiled with the debug information. In the second case, everything that
    the current project requires (e.g., imported libraries) will be rebuilt
    with the debug information.

    Finally, we can also specify the scope from which an override should
    apply. For example, we may only want to rebuild tests with the debug
    information:

    b tests/:config.cxx.coptions+=-g

  * Attribute support. Attributes are key or key=value pairs enclosed in []
    and separated with spaces. They come before the entity they apply to.
    Currently we recognize attributes for variables and values. For variables
    we recognize the following keys as types:

    bool
    uint64
    string
    path
    dir_path
    abs_dir_path
    name
    strings
    paths
    dir_paths
    names

    For example:

    [uint64] x = 01
    print $x # 1
    x += 1
    print $x # 2

    Note that variable types are global, which means you could type a variable
    that is used by another project for something completely different. As a
    result, typing of values (see below) is recommended over variables. If you
    do type a variable, make sure it has a namespace (typing of unqualified
    variables may become illegal).

    For values we recognize the same set of types plus 'null'. The value type
    is preserved in prepend/append (=+/+=) but not in assignment. For example:

    x = [uint64] 01
    print $x # 1
    x += 1
    print $x # 2

    x = [string] 01
    print $x # 01
    x += 1
    print $x # 011

    x = [null]
    print $x # [null]

    Value attributes can also be used in the evaluation contexts, for example:

    if ($x == [null])

    if ([uint64] $x == [uint64] 0)

  * Support for scope/target-qualified variable expansion. For example:

    print $(dir/:x)
    print $(file{target}:x)
    print $(dir/file{target}:x)

  * Command line options, variables, and buildspec can now be specified in any
    order. This is especially useful if you want to re-run the previous
    command with -v or add a forgotten config variable:

    b test -v
    b configure config.cxx=clang++

  * Support for the Intel C++ compiler on Linux.

  * Implement C++ compiler detection. Currently recognized compilers and their
    ids (in the <type>[-<variant>] form):

      gcc            GCC
      clang          Vanilla Clang
      clang-apple    Apple Clang (and the g++ "alias")
      icc            Intel icpc
      msvc           Microsoft cl.exe

    The compiler id, version, and other information is available via the
    following build system variables:

    cxx.id
    cxx.id.{type,variant}
    cxx.version
    cxx.version.{major,minor,patch,build}
    cxx.signature
    cxx.checksum
    cxx.target
    cxx.target.{cpu,vendor,system,version,class}

  * Implement ar/ranlib detection. The following information is available
    via the build system variables:

    bin.ar.signature
    bin.ar.checksum
    bin.ranlib.signature
    bin.ranlib.checksum

  * On update for install the C++ link rule no longer uses the -rpath
    mechanism for finding prerequisite libraries.

  * Set build.host, build.host.{cpu,vendor,system,version,class} build system
    variables to the host triplet. By default it is set to the compiler target
    build2 was built with but a more precise value can be obtained with the
    --config-guess option.

  * Set build.version, build.version.{major,minor,patch,release,string} build
    system variables to the build2 version.

  * Extracted header dependencies (-M*) are now cached in the auxiliary
    dependency (.d) files rather than being re-extracted on every run. This
    speeds up the up-to-date check significantly.

  * Revert back to only cleaning prerequisites if they are in the same project.

    Cleaning everything as long as it is in the same strong amalgamation had
    some undesirable side effects. For example, in bpkg, upgrading a package
    (which requires clean/reconfigure) led to all its prerequisites being
    cleaned as well and then rebuilt. That was surprising, to say the least.

  * Allow escaping in double-quoted strings.

  * Implement --buildfile option that can be used to specify the alternative
    file to read build information from. If '-' is specified, read from STDIN.

  * New scoping semantics. The src tree paths are no longer entered into the
    scope map. Instead, targets from the src tree now include their out tree
    directories (which are, in essence, their "configuration", with regards to
    variable lookup). The only user-visible result of this change is the extra
    '@<out-dir>/' suffix that is added when a target is printed, for example,
    as part of the compilation command lines.

Version 0.2.0

  * First public release.
