// file      : build/prerequisite -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_PREREQUISITE
#define BUILD_PREREQUISITE

#include <set>
#include <string>
#include <iosfwd>
#include <utility>    // move
#include <cassert>
#include <typeindex>
#include <functional> // reference_wrapper

#include <build/path>
#include <build/target-key>
#include <build/utility> // extension_pool
#include <build/diagnostics>

namespace build
{
  class scope;
  class target;

  // Light-weight (by being shallow-pointing) prerequisite key, similar
  // to (and based on) target key.
  //
  class prerequisite_key
  {
  public:
    typedef build::scope scope_type;

    target_key tk;
    mutable scope_type* scope; // Can be NULL if tk.dir is absolute.
  };

  inline bool
  operator< (const prerequisite_key& x, const prerequisite_key& y)
  {
    assert (x.scope == y.scope);
    return x.tk < y.tk;
  }

  std::ostream&
  operator<< (std::ostream&, const prerequisite_key&);

  class prerequisite
  {
  public:
    typedef build::target target_type;
    typedef build::target_type target_type_type;
    typedef build::scope scope_type;

    prerequisite (const target_type_type& t,
                  dir_path d,
                  std::string n,
                  const std::string* e,
                  scope_type& s)
        : type (t), dir (std::move (d)), name (std::move (n)), ext (e),
          scope (s), target (nullptr) {}

  public:
    const target_type_type& type;
    const dir_path dir;     // Normalized absolute or relative (to scope).
    const std::string name;
    const std::string* ext; // NULL if unspecified.
    scope_type& scope;
    target_type* target;    // NULL if not yet resolved. Note that this should
                            // always be the "primary target", not a member of
                            // a target group.
  public:
    // Prerequisite (target) type.
    //
    template <typename T>
    bool
    is_a () const {return type.id == typeid (T);}
  };

  inline bool
  operator< (const prerequisite& x, const prerequisite& y)
  {
    return prerequisite_key {&x.type, &x.dir, &x.name, &x.ext, &x.scope} <
      prerequisite_key {&y.type, &y.dir, &y.name, &y.ext, &y.scope};
  }

  inline std::ostream&
  operator<< (std::ostream& os, const prerequisite& p)
  {
    return os << prerequisite_key {&p.type, &p.dir, &p.name, &p.ext, &p.scope};
  }

  // Set of prerequisites in a scope.
  //
  struct prerequisite_set: std::set<prerequisite>
  {
    std::pair<prerequisite&, bool>
    insert (const target_type&,
            dir_path dir,
            std::string name,
            const std::string* ext,
            scope&,
            tracer&);
  };
}

#endif // BUILD_PREREQUISITE
