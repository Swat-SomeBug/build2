// file      : build/scope -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_SCOPE
#define BUILD_SCOPE

#include <functional>    // function
#include <unordered_set>
#include <unordered_map>

#include <build/path>
#include <build/path-map>
#include <build/variable>
#include <build/prerequisite>
#include <build/operation>

namespace build
{
  class scope
  {
  public:
    const dir_path&
    path () const {return i_->first;} // Absolute and normalized.

    const dir_path&
    src_path () const {return *src_path_;} // Corresponding src path.

    const dir_path* src_path_ {nullptr}; // Cached src_{root,base} var value.

    scope*
    parent_scope () const {return parent_;}

    // Root scope of this scope or NULL if this scope is not (yet)
    // in any (known) project. Note that if the scope itself is
    // root, then this function return this. To get to the outer
    // root, query the root scope of the parent.
    //
    scope*
    root_scope () const {return root_;}

    bool
    root () const {return root_ == this;}

    // Variables.
    //
  public:
    variable_map vars;

    // Lookup, including in outer scopes. If you only want to lookup
    // in this scope, do it on the the variables map directly.
    //
    value_proxy
    operator[] (const variable&) const;

    value_proxy
    operator[] (const std::string& name) const
    {
      return operator[] (variable_pool.find (name));
    }

    // Return a value_proxy suitable for assignment. If the variable
    // does not exist in this scope's map, then a new one with the
    // NULL value is added and returned. Otherwise the existing value
    // if returned.
    //
    value_proxy
    assign (const variable& var)
    {
      return vars.assign (var);
    }

    value_proxy
    assign (const std::string& name)
    {
      return assign (variable_pool.find (name));
    }

    // Return a value_proxy suitable for appending. If the variable
    // does not exist in this scope's map, then outer scopes are
    // searched for the same variable. If found then a new variable
    // with the found value is added to this scope and returned.
    // Otherwise this function proceeds as assign().
    //
    value_proxy
    append (const variable&);

    value_proxy
    append (const std::string& name)
    {
      return append (variable_pool.find (name));
    }

  public:
    prerequisite_set prerequisites;

    // Meta/operations supported by this project (set on the root
    // scope only).
    //
    meta_operation_table meta_operations;
    operation_table operations;

    typedef build::path path_type;

    // Set of buildfiles already loaded for this scope. The included
    // buildfiles are checked against the project's root scope while
    // imported -- against the global scope (global_scope).
    //
    std::unordered_set<path_type> buildfiles;

    // A map of absolute and normalized buildfile paths to trigger
    // functions that are executed when such files are sourced. The
    // trigger is called twice: the first time before sourcing the
    // file (pre is true) and the second time -- after (pre is false).
    //
    // The passed path is the buildfile, which can be altered by the
    // trigger in the pre call, if desired. If the returned value is
    // true, then the file is sourced. If false -- the file is ignored
    // (and no post call is made). The return value is ignored in the
    // post call.
    //
    // Note that currently triggers can only be registered on the
    // project's root scope.
    //
    using trigger_type = std::function<bool (bool pre, scope&, path_type&)>;
    std::unordered_map<path_type, trigger_type> triggers;

  private:
    friend class scope_map;
    friend class temp_scope;

    typedef dir_path_map<scope>::const_iterator iterator;

    scope () = default;

    iterator i_;
    scope* parent_;
    scope* root_;
  };

  // Temporary scope. The idea is to be able to create a temporary
  // scope in order not to change the variables in the current scope.
  // Such a scope is not entered in to the scope map. As a result it
  // can only be used as a temporary set of variables. In particular,
  // defining targets/prerequisites directly in such a scope will surely
  // end up badly. Defining any nested scopes will be as if defining
  // such a scope in the parent (since path() returns parent's path).
  //
  class temp_scope: public scope
  {
  public:
    temp_scope (scope& p) {i_ = p.i_; parent_ = &p; root_ = p.root_;}
  };

  class scope_map: public dir_path_map<scope>
  {
  public:
    // Note that we assume the first insertion into the map is that
    // of the global scope.
    //
    std::pair<scope&, bool>
    insert (const dir_path&, bool root);

    scope&
    operator[] (const dir_path& p) {return insert (p, false).first;}

    // Find the most qualified scope that encompasses this path.
    //
    scope&
    find (const dir_path&);

    scope&
    find (const path& p)
    {
      // Natural thing to do here would be to call find (p.directory ()).
      // However, there could be a situation where the passed path is a
      // directory (i.e., the calling code does not know what it is dealing
      // with), so let's use the whole path.
      //
      return find (dir_path (p.string ()));
    }

  private:
    typedef dir_path_map<scope> base;
  };

  extern scope_map scopes;
  extern scope* global_scope;
}

#endif // BUILD_SCOPE
