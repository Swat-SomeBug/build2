// file      : build/scope -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_SCOPE
#define BUILD_SCOPE

#include <functional>    // function
#include <unordered_set>
#include <unordered_map>

#include <build/path>
#include <build/path-map>
#include <build/variable>
#include <build/prerequisite>
#include <build/operation>

namespace build
{
  class scope
  {
  public:
    typedef build::path path_type;

    const path_type&
    path () const {return i_->first;} // Absolute and normalized.

    const path_type&
    src_path () const {return *src_path_;} // Corresponding src path.

    scope*
    parent () const {return parent_;}

    // Variable lookup. Note that this find, not find or insert like
    // in the variable_map, because we also search in outer scopes.
    // For the latter use the variables map directly.
    //
  public:
    value_proxy
    operator[] (const std::string&);

    value_proxy
    operator[] (const variable&);

    const path_type* src_path_ {nullptr}; // Cached src_{root,base} var value.

  private:
    friend class scope_map;

    typedef path_map<scope>::const_iterator iterator;

    scope (): variables (*this) {}

    void
    init (const iterator& i, scope* p) {i_ = i; parent_ = p;}

    void
    parent (scope& p) {parent_ = &p;}

  public:
    variable_map variables;
    prerequisite_set prerequisites;

    // Meta/operations supported by this project (set on the root
    // scope only).
    //
    meta_operation_table meta_operations;
    operation_table operations;

    // Set of buildfiles already loaded for this scope. The included
    // buildfiles are checked against the project's root scope while
    // imported -- against the global scope (global_scope).
    //
    std::unordered_set<path_type> buildfiles;

    // A map of buildfiles to trigger functions that are executed when
    // such files are sourced. The path must be absolute and normalized.
    //
    // The passed path is the buildfile. If the returned value is true,
    // then the file is sourced. If false -- the file is ignored. Note
    // that currently triggers can only be registered on the project's
    // root scope.
    //
    using trigger_type = std::function<bool (scope&, const path_type&)>;
    std::unordered_map<path_type, trigger_type> triggers;

  private:
    iterator i_;
    scope* parent_;
  };

  class scope_map: public path_map<scope>
  {
  public:
    // Note that we assume the first insertion into the map is that
    // of the global scope.
    //
    std::pair<scope&, bool>
    insert (const path&);

    scope&
    operator[] (const path& p) {return insert (p).first;}

    // Find the most qualified scope that encompasses this path.
    //
    scope&
    find (const path&);

  private:
    typedef path_map<scope> base;
  };

  extern scope_map scopes;
  extern scope* global_scope;
}

#endif // BUILD_SCOPE
