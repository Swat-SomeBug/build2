// file      : build/target -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_TARGET
#define BUILD_TARGET

#include <set>
#include <map>
#include <string>
#include <vector>
#include <memory>     // unique_ptr
#include <functional> // function, reference_wrapper
#include <typeindex>
#include <iosfwd>
#include <cassert>
#include <utility>    // move

#include <build/path>
#include <build/timestamp>
#include <build/prerequisite>
#include <build/utility>       // compare_*, extension_pool

namespace build
{
  class target;

  enum class target_state {unknown, uptodate, updated, failed};
  typedef std::function<target_state (target&)> recipe;

  struct target_type
  {
    std::type_index id;
    const char* name;
    const target_type* base;
    target* (*const factory) (path, std::string, const std::string*);
  };

  class target
  {
  public:
    target (path d, std::string n, const std::string* e)
        : directory (std::move (d)), name (std::move (n)), ext (e) {}

    const path directory;   // Absolute and normalized.
    const std::string name;
    const std::string* ext; // Extension, NULL means unspecified.

  public:
    typedef
    std::vector<std::reference_wrapper<prerequisite>>
    prerequisites_type;

    prerequisites_type prerequisites;

  public:
    typedef build::recipe recipe_type;

    const recipe_type&
    recipe () const {return recipe_;}

    void
    recipe (recipe_type r) {assert (!recipe_); recipe_ = r;}

  public:
    target_state
    state () const {return state_;}

    void
    state (target_state s) {state_ = s;}

  private:
    target (const target&) = delete;
    target& operator= (const target&) = delete;

  public:
    virtual const target_type& type () const = 0;
    static const target_type static_type;

  private:
    recipe_type recipe_;
    target_state state_ {target_state::unknown};
  };

  std::ostream&
  operator<< (std::ostream&, const target&);

  inline bool
  operator< (const target& x, const target& y)
  {
    std::type_index tx (typeid (x)), ty (typeid (y));

    //@@ TODO: use compare() to compare once.

    // Unspecified and specified extension are assumed equal. The
    // extension strings are from the pool, so we can just compare
    // pointers.
    //
    return
      (tx < ty) ||
      (tx == ty && x.name < y.name) ||
      (tx == ty && x.name == y.name && x.directory < y.directory) ||
      (tx == ty && x.name == y.name && x.directory == y.directory &&
       x.ext != nullptr && y.ext != nullptr && x.ext < y.ext);
  }

  typedef std::set<std::unique_ptr<target>, compare_pointer_target> target_set;
  extern target_set targets;
  extern target* default_target;

  class target_type_map: public std::map<
    const char*,
    std::reference_wrapper<const target_type>,
    compare_c_string>
  {
  public:
    void
    insert (const target_type& tt) {emplace (tt.name, tt);}
  };

  extern target_type_map target_types;

  template <typename T>
  target*
  target_factory (path d, std::string n, const std::string* e)
  {
    return new T (std::move (d), std::move (n), e);
  }

  // Modification time-based target.
  //
  class mtime_target: public target
  {
  public:
    using target::target;

    timestamp
    mtime () const
    {
      if (mtime_ == timestamp_unknown)
        mtime_ = load_mtime ();

      return mtime_;
    }

    void
    mtime (timestamp mt) {mtime_ = mt;}

  protected:
    virtual timestamp
    load_mtime () const = 0;

  public:
    static const target_type static_type;

  private:
    mutable timestamp mtime_ {timestamp_unknown};
  };

  // Filesystem path-bases target.
  //
  class path_target: public mtime_target
  {
  public:
    using mtime_target::mtime_target;

    typedef build::path path_type;

    const path_type&
    path () const {return path_;}

    void
    path (path_type p) {assert (path_.empty ()); path_ = p;}

  protected:
    virtual timestamp
    load_mtime () const;

  public:
    static const target_type static_type;

  private:
    path_type path_;
  };

  // File target.
  //
  class file: public path_target
  {
  public:
    using path_target::path_target;

  public:
    virtual const target_type& type () const {return static_type;}
    static const target_type static_type;
  };
}

#endif // BUILD_TARGET
