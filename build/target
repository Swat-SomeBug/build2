// file      : build/target -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_TARGET
#define BUILD_TARGET

#include <map>
#include <string>
#include <vector>
#include <memory>     // unique_ptr
#include <cstddef>    // size_t
#include <functional> // function, reference_wrapper
#include <typeindex>
#include <ostream>
#include <cassert>
#include <utility>    // move()

#include <build/path>
#include <build/key-set>
#include <build/timestamp>
#include <build/name>
#include <build/operation>
#include <build/prerequisite>
#include <build/utility>       // compare_*, extension_pool

namespace build
{
  class target;

  // Target state.
  //
  enum class target_state {unknown, unchanged, changed, failed};

  // Recipe.
  //
  // The returned target state should be either changed or unchanged.
  // If there is an error, then the recipe should throw rather than
  // returning failed.
  //
  // The recipe execution protocol is as follows: before executing
  // the recipe, the caller sets the target's state to failed. If
  // the recipe returns normally and the target's state is still
  // failed, then the caller sets it to the returned value. This
  // means that the recipe can set the target's state manually to
  // some other value. For example, setting it to unknown will
  // result in the recipe to be executed again if this target is
  // a prerequisite of another target. Note that in this case the
  // returned by the recipe value is still used (by the caller) as
  // the resulting target state for this execution of the recipe.
  //
  using recipe_function = target_state (action, target&);
  using recipe = std::function<recipe_function>;

  // Commonly-used recipes. The default recipe executes the action
  // on all the prerequisites in a loop, skipping ignored (see the
  // execute_prerequisites() in <algorithm> for details).
  //
  extern const recipe empty_recipe;
  extern const recipe noop_recipe;
  extern const recipe default_recipe;

  target_state
  noop_recipe_function (action, target&);

  // Target type.
  //
  struct target_type
  {
    std::type_index id;
    const char* name;
    const target_type* base;
    target* (*const factory) (path, std::string, const std::string*);
    target* (*const search) (prerequisite&);
  };

  inline std::ostream&
  operator<< (std::ostream& os, const target_type& tt)
  {
    return os << tt.name;
  }

  class target
  {
  public:
    virtual
    ~target () = default;

    target (path d, std::string n, const std::string* e)
        : dir (std::move (d)), name (std::move (n)), ext (e) {}

    const path dir;         // Absolute and normalized.
    const std::string name;
    const std::string* ext; // Extension, NULL means unspecified.

  public:
    typedef
    std::vector<std::reference_wrapper<prerequisite>>
    prerequisites_type;

    prerequisites_type prerequisites;

  public:
    target_state state;

    // Number of direct targets that depend on this target in the current
    // action. It is incremented during the match phase and then decremented
    // during execution, before running the recipe. As a result, the recipe
    // can detect the last chance (i.e., last dependent) to execute the
    // command ("front-running" vs "back-running" recipes).
    //
    // Note that setting a new recipe (which happens when we match the rule
    // and which in turn is triggered by the first dependent) clears this
    // counter. However, if the previous action was the same as the current,
    // then the existing recipe is reused. In this case, however, the counter
    // should have been decremented to 0 naturally, as part of the previous
    // action execution.
    //
    std::size_t dependents;

  public:
    typedef build::recipe recipe_type;

    const recipe_type&
    recipe (action_id a) const {return action_ == a ? recipe_ : empty_recipe;}

    void
    recipe (action_id a, recipe_type r)
    {
      assert (action_ != a || !recipe_);
      action_ = a;
      recipe_ = std::move (r);

      // Also reset the target state. If this is a noop recipe, then
      // mark the target unchanged so that we don't waste time executing
      // the recipe.
      //
      recipe_function** f (recipe_.target<recipe_function*> ());
      state = (f == nullptr || *f != &noop_recipe_function)
        ? target_state::unknown
        : target_state::unchanged;

      dependents = 0;
    }

  private:
    target (const target&) = delete;
    target& operator= (const target&) = delete;

  public:
    virtual const target_type& type () const = 0;
    static const target_type static_type;

  private:
    action_id action_ {0}; // Action id of this recipe.
    recipe_type recipe_;
  };

  std::ostream&
  operator<< (std::ostream&, const target&);

  struct target_set
  {
    struct key
    {
      mutable const target_type* type;
      mutable const path* dir;
      mutable const std::string* name;
      mutable const std::string* const* ext;

      friend bool
      operator< (const key& x, const key& y)
      {
        const std::type_index& xt (x.type->id);
        const std::type_index& yt (y.type->id);

        //@@ TODO: use compare() to compare once.

        // Unspecified and specified extension are assumed equal. The
        // extension strings are from the pool, so we can just compare
        // pointers.
        //
        return
          (xt < yt) ||
          (xt == yt && *x.name < *y.name) ||
          (xt == yt && *x.name == *y.name && *x.dir < *y.dir) ||
          (xt == yt && *x.name == *y.name && *x.dir == *y.dir &&
           *x.ext != nullptr && *y.ext != nullptr && **x.ext < **y.ext);
      }
    };

    typedef std::map<key, std::unique_ptr<target>> map;
    typedef map_iterator_adapter<map::const_iterator> iterator;

    iterator
    find (const key& k, tracer& trace) const;

    iterator
    find (const target_type& type,
          const path& dir,
          const std::string& name,
          const std::string* ext,
          tracer& trace) const
    {
      const std::string* e (ext);
      return find (key {&type, &dir, &name, &e}, trace);
    }

    iterator begin () const {return map_.begin ();}
    iterator end () const {return map_.end ();}

    std::pair<target&, bool>
    insert (const target_type&,
            path dir,
            std::string name,
            const std::string* ext,
            tracer&);

  private:
    map map_;
  };

  std::ostream&
  operator<< (std::ostream&, const target_set::key&);

  extern target_set targets;

  class target_type_map: public std::map<
    const char*,
    std::reference_wrapper<const target_type>,
    compare_c_string>
  {
  public:
    typedef std::map<const char*,
                     std::reference_wrapper<const target_type>,
                     compare_c_string> base;

    void
    insert (const target_type& tt) {emplace (tt.name, tt);}

    using base::find;

    // Given a name, figure out its type, taking into account extensions,
    // special names (e.g., '.' and '..'), or anything else that might be
    // relevant. Also process the name (in place) by extracting the
    // extension, adjusting dir/value, etc (note that the dir is not
    // necessarily normalized). Return NULL if not found.
    //
    const target_type*
    find (name&, const std::string*& ext) const;
  };

  extern target_type_map target_types;

  template <typename T>
  target*
  target_factory (path d, std::string n, const std::string* e)
  {
    return new T (std::move (d), std::move (n), e);
  }

  // Modification time-based target.
  //
  class mtime_target: public target
  {
  public:
    using target::target;

    timestamp
    mtime () const
    {
      if (mtime_ == timestamp_unknown)
        mtime_ = load_mtime ();

      return mtime_;
    }

    void
    mtime (timestamp mt) {mtime_ = mt;}

  protected:
    virtual timestamp
    load_mtime () const = 0;

  public:
    static const target_type static_type;

  private:
    mutable timestamp mtime_ {timestamp_unknown};
  };

  // Filesystem path-based target.
  //
  class path_target: public mtime_target
  {
  public:
    using mtime_target::mtime_target;

    typedef build::path path_type;

    const path_type&
    path () const {return path_;}

    void
    path (path_type p) {assert (path_.empty ()); path_ = std::move (p);}

  protected:
    virtual timestamp
    load_mtime () const;

  public:
    static const target_type static_type;

  private:
    path_type path_;
  };

  // File target.
  //
  class file: public path_target
  {
  public:
    using path_target::path_target;

  public:
    virtual const target_type& type () const {return static_type;}
    static const target_type static_type;
  };

  // Directory alias/action target. Note that it is not mtime-based.
  // Rather it is meant to represent a group of targets. For actual
  // filesystem directory (creation), see fsdir.
  //
  class dir: public target
  {
  public:
    using target::target;

  public:
    virtual const target_type& type () const {return static_type;}
    static const target_type static_type;
  };

  // While a filesystem directory is mtime-based, the semantics is
  // not very useful in our case. In particular, if another target
  // depends on fsdir{}, then all that's desired is the creation of
  // the directory if it doesn't already exist. In particular, we
  // don't want to update the target just because some unrelated
  // entry was created in that directory.
  //
  class fsdir: public target
  {
  public:
    using target::target;

  public:
    virtual const target_type& type () const {return static_type;}
    static const target_type static_type;
  };
}

#endif // BUILD_TARGET
