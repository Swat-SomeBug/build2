// file      : build/name -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_NAME
#define BUILD_NAME

#include <string>
#include <vector>
#include <iosfwd>
#include <utility> // move()

#include <butl/path>

// Note: include <build/types> instead of this file directly.
//
namespace build
{
  using butl::dir_path;

  // A name is what we operate on by default. Depending on the context,
  // it can be interpreted as a target or prerequisite name. A name
  // without a type and directory can be used to represent any text.
  // A name with directory and empty value represents a directory.
  //
  // If pair is true, then this name and the next in the list form
  // a pair.
  //
  struct name
  {
    name () = default;

    explicit
    name (std::string v): value (std::move (v)) {}

    explicit
    name (dir_path d): dir (std::move (d)) {}

    name (std::string t, dir_path d, std::string v)
        : type (std::move (t)), dir (std::move (d)), value (std::move (v)) {}

    bool
    empty () const {return type.empty () && dir.empty () && value.empty ();}

    bool
    simple () const {return type.empty () && dir.empty ();}

    bool
    directory () const
    {return type.empty () && !dir.empty () && value.empty ();}

    std::string type;
    dir_path dir;
    std::string value;
    char pair = '\0'; // Pair symbol, if any.
  };

  inline bool
  operator== (const name& x, const name& y)
  {
    return x.type == y.type && x.dir == y.dir && x.value == y.value;
  }

  inline bool
  operator!= (const name& x, const name& y) {return !(x == y);}

  typedef std::vector<name> names;

  std::ostream&
  operator<< (std::ostream&, const name&);

  std::ostream&
  operator<< (std::ostream&, const names&);
}

#endif // BUILD_NAME
