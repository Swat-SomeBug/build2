// file      : build/config/utility -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_CONFIG_UTILITY
#define BUILD_CONFIG_UTILITY

#include <string>
#include <utility> // pair

#include <build/types>
#include <build/diagnostics>

namespace build
{
  class scope;
  class list_value;

  namespace config
  {
    // Set, if necessary, a required config.* variable.
    //
    // Return the reference to the value as well as the indication of
    // whether the variable has actually been set.
    //
    template <typename T>
    std::pair<const T&, bool>
    required (scope& root, const char* name, const T& default_value);

    template <typename T>
    inline std::pair<const T&, bool>
    required (scope& root, const std::string& name, const T& default_value)
    {
      return required<T> (root, name.c_str (), default_value);
    }

    std::pair<const std::string&, bool>
    required (scope& root, const char* name, const char* default_value);

    // Set, if necessary, an optional config.* variable. In particular,
    // an unspecified variable is set to NULL which is used to distinguish
    // between the "configured as unspecified" and "not yet configured"
    // cases.
    //
    // Return the pointer to the value, which can be NULL.
    //
    template <typename T>
    const T*
    optional (scope& root, const char* name);

    template <typename T>
    inline const T*
    optional (scope& root, const std::string& name)
    {
      return optional<T> (root, name.c_str ());
    }

    // Check whether there are any variables specified from the
    // config namespace. The idea is that we can check if there
    // are any, say, config.install.* values. If there are none,
    // then we can assume this functionality is not (yet) used
    // and omit writing a whole bunch of NULL config.install.*
    // values to config.build. We call it omitted/delayed
    // configuration.
    //
    bool
    specified (scope& root, const std::string& ns);

    // @@ Why are these here?
    //

    // Add all the values from a variable to the C-string list. T is
    // either target or scope.
    //
    template <typename T>
    void
    append_options (cstrings& args, T& s, const char* var);

    // As above but from the list value directly. Variable name is for
    // diagnostics.
    //
    void
    append_options (cstrings& args, const list_value&, const char* var);

    // Check if a specified option is present. T is either target or scope.
    //
    template <typename T>
    bool
    find_option (const char* option, T& s, const char* var);
  }
}

#include <build/config/utility.txx>

#endif // BUILD_CONFIG_UTILITY
