// file      : build/rule -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_RULE
#define BUILD_RULE

#include <string>
#include <cstddef>        // nullptr_t

#include <build/types>
#include <build/target>
#include <build/operation>

namespace build
{
  class match_result
  {
  public:
    typedef build::target target_type;
    typedef build::prerequisite prerequisite_type;

    // Can contain neither (both are NULL), one of, or both. If both
    // are NULL, then it is a "no match" indicator.
    //
    // Note that if the "payload" is stored in value instead of
    // prerequisite, then target must not be NULL.
    //
    union
    {
      prerequisite_type* prerequisite;
      bool value;
    };

    target_type* target;

    action recipe_action = action (); // Used as recipe's action if set.

    match_result (target_type& t, bool v): value (v), target (&t) {}
    match_result (std::nullptr_t v = nullptr): prerequisite (v), target (v) {}
    match_result (prerequisite_type& p): prerequisite (&p), target (nullptr) {}
    match_result (prerequisite_type* p): prerequisite (p), target (nullptr) {}
    match_result (target_type& t): prerequisite (nullptr), target (&t) {}
    match_result (target_type* t): prerequisite (nullptr), target (t) {}
    match_result (const prerequisite_member& pm)
        : prerequisite (&pm.prerequisite.get ()), target (pm.target) {}

    explicit
    operator bool () const
    {
      return target != nullptr || prerequisite != nullptr;
    }
  };

  class rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const = 0;

    virtual recipe
    apply (action, target&, const match_result&) const = 0;
  };

  // Fallback rule that on update verifies that the file exists and is
  // not older than any of its prerequisites.
  //
  class file_rule: public rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const;

    virtual recipe
    apply (action, target&, const match_result&) const;

    static target_state
    perform_update (action, target&);

    // Sometimes it is useful, normally as an optimization, to check
    // if the file target is up to date. In particular, if the rule
    // that matched a target is this fallback rule and the target
    // has no prerequisites, then it means it is up to date.
    //
    static bool
    uptodate (action a, target& t)
    {
      recipe_function* const* r (t.recipe (a).target<recipe_function*> ());
      return r != nullptr && *r == &perform_update &&
        t.prerequisites.empty () &&
        (t.group == nullptr || t.group->prerequisites.empty ());
    }

    static file_rule instance;
  };

  class alias_rule: public rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const;

    virtual recipe
    apply (action, target&, const match_result&) const;

    static alias_rule instance;
  };

  class fsdir_rule: public rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const;

    virtual recipe
    apply (action, target&, const match_result&) const;

    static target_state
    perform_update (action, target&);

    static target_state
    perform_clean (action, target&);

    static fsdir_rule instance;
  };
}

#endif // BUILD_RULE
