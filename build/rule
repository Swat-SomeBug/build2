// file      : build/rule -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_RULE
#define BUILD_RULE

#include <string>
#include <cstddef>        // nullptr_t
#include <typeindex>
#include <functional>     // reference_wrapper
#include <unordered_map>

#include <butl/prefix-map>

#include <build/types>
#include <build/target>
#include <build/operation>

namespace build
{
  class match_result
  {
  public:
    typedef build::target target_type;
    typedef build::prerequisite prerequisite_type;

    // Can contain neither (both are NULL), one of, or both. If both
    // are NULL, then it is a "no match" indicator.
    //
    prerequisite_type* prerequisite;
    target_type* target;

    match_result (std::nullptr_t v = nullptr): prerequisite (v), target (v) {}
    match_result (prerequisite_type& p): prerequisite (&p), target (nullptr) {}
    match_result (prerequisite_type* p): prerequisite (p), target (nullptr) {}
    match_result (target_type& t): prerequisite (nullptr), target (&t) {}
    match_result (target_type* t): prerequisite (nullptr), target (t) {}
    match_result (const prerequisite_member& pm)
        : prerequisite (&pm.prerequisite.get ()), target (pm.target) {}

    explicit
    operator bool () const
    {
      return prerequisite != nullptr || target != nullptr;
    }
  };

  class rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const = 0;

    virtual recipe
    apply (action, target&, const match_result&) const = 0;
  };

  using target_rule_map = std::unordered_map<
    std::type_index,
    butl::prefix_map<std::string, std::reference_wrapper<rule>, '.'>>;

  using operation_rule_map = std::unordered_map<operation_id, target_rule_map>;

  extern operation_rule_map rules;

  // Fallback rule that on update verifies that the path exists and is
  // not older than any of its prerequisites.
  //
  class path_rule: public rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const;

    virtual recipe
    apply (action, target&, const match_result&) const;

    static target_state
    perform_update (action, target&);
  };

  class dir_rule: public rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const;

    virtual recipe
    apply (action, target&, const match_result&) const;
  };

  class fsdir_rule: public rule
  {
  public:
    virtual match_result
    match (action, target&, const std::string& hint) const;

    virtual recipe
    apply (action, target&, const match_result&) const;

    static target_state
    perform_update (action, target&);

    static target_state
    perform_clean (action, target&);
  };
}

#endif // BUILD_RULE
