// file      : build/utility -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_UTILITY
#define BUILD_UTILITY

#include <tuple>
#include <limits> // numeric_limits
#include <string>
#include <vector>
#include <utility>
#include <cstring> // strcmp()
#include <cassert>
#include <exception>
#include <unordered_set>
#include <unordered_map>

#include <build/path>

namespace build
{
  // Empty string and path.
  //
  extern const std::string empty_string;
  extern const path empty_path;

  // Comparators.
  //
  struct compare_c_string
  {
    bool operator() (const char* x, const char* y) const
    {
      return std::strcmp (x, y) < 0;
    }
  };

  struct compare_pointer_target
  {
    template <typename P>
    bool operator() (const P& x, const P& y) const {return *x < *y;}
  };

  // Call a function if there is an exception.
  //

  // Means we are in the body of a destructor that is being called
  // as part of the exception stack unwindining. Used to compensate
  // for the deficiencies of uncaught_exception() until C++17
  // uncaught_exceptions() becomes available.
  //
  // @@ MT: will have to be TLS.
  //
  extern bool exception_unwinding_dtor;

  template <typename F, typename T>
  struct exception_guard;

  template <typename F, typename... A>
  inline exception_guard<F, std::tuple<A&&...>>
  make_exception_guard (F f, A&&... a)
  {
    return exception_guard<F, std::tuple<A&&...>> (
      std::move (f), std::forward_as_tuple (a...));
  }

  template <typename F, typename... A>
  struct exception_guard<F, std::tuple<A...>>
  {
    typedef std::tuple<A...> T;

    exception_guard (F f, T a): f_ (std::move (f)), a_ (std::move (a)) {}
    ~exception_guard ()
    {
      if (std::uncaught_exception ())
      {
        exception_unwinding_dtor = true;
        call (std::index_sequence_for<A...> ());
        exception_unwinding_dtor = false;
      }
    }

  private:
    template <std::size_t... I>
    void
    call (std::index_sequence<I...>) {f_ (std::get<I> (a_)...);}

    F f_;
    T a_;
  };

  // Pools (@@ perhaps move into a separate header).
  //
  struct string_pool: std::unordered_set<std::string>
  {
    const std::string&
    find (const char* s) {return *emplace (s).first;}
  };

  extern string_pool extension_pool;

  // A pool of strings in which each string is assigned an individual
  // index (or id) of type I (e.g., uint8_t, uint16_t, etc., depending
  // on how many entries are expected). Index value 0 is reserved to
  // indicate the no entry condition.
  //
  template <typename I>
  struct string_table
  {
    // Find existing or insert new.
    //
    I
    insert (const std::string& s)
    {
      std::size_t i (vec_.size () + 1);
      auto r (map_.emplace (s, static_cast<I> (i)));

      if (r.second)
      {
        assert (i <= std::numeric_limits<I>::max ());
        vec_.push_back (&r.first->first);
      }

      return r.first->second;
    }

    // Find existing.
    //
    I
    find (const std::string& s) const
    {
      auto i (map_.find (s));
      return i != map_.end () ? i->second : 0;
    }

    // Reverse lookup.
    //
    const std::string&
    operator[] (I i) const {assert (i > 0); return *vec_[i - 1];}

    I
    size () const {return static_cast<I> (vec_.size ());}

  private:
    std::unordered_map<std::string, I> map_;
    std::vector<const std::string*> vec_;
  };
}

#endif // BUILD_UTILITY
