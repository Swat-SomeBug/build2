// file      : build/utility -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_UTILITY
#define BUILD_UTILITY

#include <tuple>
#include <string>
#include <utility>
#include <cstring> // strcmp()
#include <exception>
#include <unordered_set>

#include <build/path>

namespace build
{
  // Empty string and path.
  //
  extern const std::string empty_string;
  extern const path empty_path;
  extern const dir_path empty_dir_path;

  // Comparators.
  //
  struct compare_c_string
  {
    bool operator() (const char* x, const char* y) const
    {
      return std::strcmp (x, y) < 0;
    }
  };

  struct compare_pointer_target
  {
    template <typename P>
    bool operator() (const P& x, const P& y) const {return *x < *y;}
  };

  // Simple optional class template while waiting for std::optional.
  //
  template <typename T>
  class optional
  {
  public:
    typedef T value_type;

    optional (): null_ (true) {}
    optional (const T& v): value_ (v), null_ (false) {}
    optional& operator= (const T& v) {value_ = v; null_ = false; return *this;}

    T&       value () {return value_;}
    const T& value () const {return value_;}

    T*       operator-> () {return &value_;}
    const T* operator-> () const {return &value_;}

    T&       operator* () {return value_;}
    const T& operator* () const {return value_;}

    explicit operator bool () const {return !null_;}

  private:
    T value_;
    bool null_;
  };


  // Support for reverse iteration using range-based for-loop:
  //
  // for (... : reverse_iterate (x)) ...
  //
  template <typename T>
  class reverse_range
  {
    T& x_;

  public:
    reverse_range (T& x): x_ (x) {}

    auto begin () -> decltype (this->x_.rbegin ())
    {
      return x_.rbegin ();
    }

    auto end () -> decltype (this->x_.rend ())
    {
      return x_.rend ();
    }
  };

  template <typename T>
  inline reverse_range<T>
  reverse_iterate (T& x)
  {
    return reverse_range<T> (x);
  }

  template <typename T>
  inline reverse_range<const T>
  reverse_iterate (const T& x)
  {
    return reverse_range<const T> (x);
  }

  // Call a function if there is an exception.
  //

  // Means we are in the body of a destructor that is being called
  // as part of the exception stack unwindining. Used to compensate
  // for the deficiencies of uncaught_exception() until C++17
  // uncaught_exceptions() becomes available.
  //
  // @@ MT: will have to be TLS.
  //
  extern bool exception_unwinding_dtor;

  template <typename F, typename T>
  struct exception_guard;

  template <typename F, typename... A>
  inline exception_guard<F, std::tuple<A&&...>>
  make_exception_guard (F f, A&&... a)
  {
    return exception_guard<F, std::tuple<A&&...>> (
      std::move (f), std::forward_as_tuple (a...));
  }

  template <typename F, typename... A>
  struct exception_guard<F, std::tuple<A...>>
  {
    typedef std::tuple<A...> T;

    exception_guard (F f, T a): f_ (std::move (f)), a_ (std::move (a)) {}
    ~exception_guard ()
    {
      if (std::uncaught_exception ())
      {
        exception_unwinding_dtor = true;
        call (std::index_sequence_for<A...> ());
        exception_unwinding_dtor = false;
      }
    }

  private:
    template <std::size_t... I>
    void
    call (std::index_sequence<I...>) {f_ (std::get<I> (a_)...);}

    F f_;
    T a_;
  };

  // Pools (@@ perhaps move into a separate header).
  //
  struct string_pool: std::unordered_set<std::string>
  {
    const std::string&
    find (const char* s) {return *emplace (s).first;}
  };

  extern string_pool extension_pool;
}

#endif // BUILD_UTILITY
