// file      : build/variable -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_VARIABLE
#define BUILD_VARIABLE

#include <map>
#include <string>
#include <memory>        // unique_ptr
#include <cstddef>       // nullptr_t
#include <utility>       // move(), pair, make_pair()
#include <cassert>
#include <functional>    // hash, reference_wrapper
#include <typeindex>
#include <unordered_set>

#include <butl/prefix-map>

#include <build/types>
#include <build/target-type>

namespace build
{
  struct value;

  struct value_type
  {
    std::type_index id;
    value* (*const factory) ();
  };

  // variable
  //
  // The two variables are considered the same if they have the same name.
  //
  struct variable
  {
    explicit
    variable (std::string n, char p = '\0'): name (std::move (n)), pairs (p) {}

    std::string name;
    char pairs;
    //const value_type* type = nullptr; // If NULL, then no fixed type.
  };

  inline bool
  operator== (const variable& x, const variable& y) {return x.name == y.name;}

  typedef std::reference_wrapper<const variable> variable_cref;

  // value
  //
  struct value;
  typedef std::unique_ptr<value> value_ptr;

  struct value
  {
  public:
    virtual value_ptr
    clone () const = 0;

    virtual bool
    compare (const value&) const = 0;

    virtual
    ~value () = default;
  };

  class list_value: public value, public names
  {
  public:
    using names::names;

    list_value () = default;
    explicit list_value (names d): names (std::move (d)) {}
    explicit list_value (name n) {emplace_back (std::move (n));}
    explicit list_value (dir_path d) {emplace_back (std::move (d));}
    explicit list_value (std::string s) {emplace_back (std::move (s));}
    explicit list_value (const char* s) {emplace_back (s);}

    virtual value_ptr
    clone () const {return value_ptr (new list_value (*this));}

    virtual bool
    compare (const value& v) const
    {
      const list_value* lv (dynamic_cast<const list_value*> (&v));
      return lv != nullptr && static_cast<const names&> (*this) == *lv;
    }

    // Pair (i.e., key-value) search. Note that this funtion assumes
    // the list contains only pairs and keys are simple names. Returns
    // NULL if not found.
    //
    const name*
    find_pair (const std::string& key) const
    {
      for (auto i (begin ()); i != end (); i += 2)
        if (i->value == key)
          return &*++i;
      return nullptr;
    }
  };
  typedef std::unique_ptr<list_value> list_value_ptr;

  // value_proxy
  //
  // A variable can be undefined, null, or contain some actual value.
  // Note that once value_proxy is bound to a value, the only way to
  // rebind it to a different value is by using explicit rebind(). In
  // particular, assigning one value proxy to another will assing the
  // values.
  //
  struct variable_map;

  struct value_proxy
  {
    bool
    defined () const {return p != nullptr;}

    bool
    null () const {return *p == nullptr;}

    bool
    empty () const;

    explicit operator bool () const {return defined () && !null ();}
    explicit operator value_ptr& () const {return *p;}

    // Get interface. See available specializations below.
    //
    template <typename T>
    T
    as () const;

    // Assign.
    //
    const value_proxy&
    operator= (value_ptr) const;

    const value_proxy&
    operator= (const value_proxy&) const;

    const value_proxy&
    operator= (list_value) const;

    const value_proxy&
    operator= (std::string) const;

    const value_proxy&
    operator= (dir_path) const;

    const value_proxy&
    operator= (std::nullptr_t) const;

    // Append.
    //
    const value_proxy&
    operator+= (const value_proxy&) const;

    const value_proxy&
    operator+= (const list_value&) const;

    const value_proxy&
    operator+= (std::string) const; // Append simple name to list_value.

    // Return true if this value belongs to the specified scope or target.
    // Note that it can also be a target type/pattern-specific value.
    //
    template <typename T>
    bool
    belongs (const T& x) const {return vars == &x.vars;}

    // Implementation details.
    //
    const variable_map* vars; // Variable map to which this value belongs.

    value_proxy (): vars (nullptr), p (nullptr) {}
    value_proxy (value_ptr* p, const variable_map* v)
        : vars (p != nullptr ? v : nullptr), p (p) {}

    template <typename T>
    value_proxy (value_ptr& p, const T& x)
        : value_proxy (&p, &x.vars) {}

    // @@ To do this properly we seem to need ro_value_proxy?
    //
    value_proxy (const value_ptr* p, const variable_map* v)
        : value_proxy (const_cast<value_ptr*> (p), v) {}

    template <typename T>
    value_proxy (const value_ptr& p, const T& x)
        : value_proxy (const_cast<value_ptr&> (p), x) {}

    void
    rebind (const value_proxy& x) {vars = x.vars; p = x.p;}

  private:
    value_ptr* p;
  };

  template <>
  inline value& value_proxy::
  as<value&> () const {return **p;}

  template <>
  inline const value& value_proxy::
  as<const value&> () const {return **p;}

  template <>
  inline list_value& value_proxy::
  as<list_value&> () const
  {
    list_value* lv (dynamic_cast<list_value*> (p->get ()));
    assert (lv != nullptr);
    return *lv;
  }

  template <>
  inline const list_value& value_proxy::
  as<const list_value&> () const {return as<list_value&> ();}

  template <>
  inline const name* value_proxy::
  as<const name*> () const
  {
    const auto& lv (as<const list_value&> ());
    assert (lv.size () < 2);
    return lv.empty () ? nullptr : &lv.front ();
  }

  template <>
  inline const name& value_proxy::
  as<const name&> () const
  {
    const auto& lv (as<const list_value&> ());
    assert (lv.size () == 1);
    return lv.front ();
  }

  template <>
  std::string& value_proxy::
  as<std::string&> () const;

  template <>
  const std::string& value_proxy::
  as<const std::string&> () const;

  template <>
  dir_path& value_proxy::
  as<dir_path&> () const;

  template <>
  const dir_path& value_proxy::
  as<const dir_path&> () const;

  template <>
  bool value_proxy::
  as<bool> () const;
}

namespace std
{
  template <>
  struct hash<build::variable>: hash<string>
  {
    size_t
    operator() (const build::variable& v) const noexcept
    {
      return hash<string>::operator() (v.name);
    }
  };
}

namespace butl
{
  template <>
  struct compare_prefix<build::variable_cref>: compare_prefix<std::string>
  {
    typedef compare_prefix<std::string> base;

    explicit
    compare_prefix (char d): base (d) {}

    bool
    operator() (const build::variable& x, const build::variable& y) const
    {
      return base::operator() (x.name, y.name);
    }

    bool
    prefix (const build::variable& p, const build::variable& k) const
    {
      return base::prefix (p.name, k.name);
    }
  };
}

namespace build
{
  // variable_pool
  //
  struct variable_set: std::unordered_set<variable>
  {
    // @@ Need to check/set type?
    //
    const variable&
    find (std::string name) {return *emplace (std::move (name)).first;}

    const variable&
    insert (variable v) {return *emplace (std::move (v)).first;}
  };

  extern variable_set variable_pool;

  // variable_map
  //
  struct variable_map
  {
    using map_type = butl::prefix_map<variable_cref, value_ptr, '.'>;
    using size_type = map_type::size_type;
    using const_iterator = map_type::const_iterator;

    const value_ptr*
    find (const variable& var) const
    {
      auto i (m_.find (var));
      return i != m_.end () ? &i->second : nullptr;
    }

    value_proxy
    operator[] (const variable& var) const
    {
      return value_proxy (find (var), this);
    }

    value_proxy
    operator[] (const std::string& name) const
    {
      return operator[] (variable_pool.find (name));
    }

    // The second member in the pair indicates whether new (NULL)
    // value was set.
    //
    std::pair<value_proxy, bool>
    assign (const variable& var)
    {
      auto r (m_.emplace (var, value_ptr ()));
      return std::make_pair (value_proxy (&r.first->second, this), r.second);
    }

    std::pair<value_proxy, bool>
    assign (const std::string& name)
    {
      return assign (variable_pool.find (name));
    }

    std::pair<const_iterator, const_iterator>
    find_namespace (const std::string& ns) const
    {
      return m_.find_prefix (variable_pool.find (ns));
    }

    const_iterator
    begin () const {return m_.begin ();}

    const_iterator
    end () const {return m_.end ();}

    bool
    empty () const {return m_.empty ();}

    size_type
    size () const {return m_.size ();}

  private:
    map_type m_;
  };

  // Target type/pattern-specific variables.
  //
  using variable_pattern_map = std::map<std::string, variable_map>;
  using variable_type_map = std::map<std::reference_wrapper<const target_type>,
                                     variable_pattern_map>;

  //@@ In quite a few places we assume that we can store a reference
  //   to the returned value (e.g., install::lookup_install()). If
  //   we "instantiate" the value on the fly, then we will need to
  //   consider its lifetime.

}

#include <build/variable.ixx>

#endif // BUILD_VARIABLE
