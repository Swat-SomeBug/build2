// file      : build/lexer -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_LEXER
#define BUILD_LEXER

#include <string>
#include <iosfwd>
#include <cstdint> // uint64_t
#include <exception>

#include <butl/char-scanner>

#include <build/token>
#include <build/diagnostics>

namespace build
{
  // Context-dependent lexing mode. In the value mode we don't treat
  // certain characters (e.g., +, =) as special so that we can use
  // them in the variable values, e.g., 'foo = g++'. In contrast,
  // in the variable mode, we restrict certain character (e.g., /)
  // from appearing in the name. The pairs mode is just like value
  // except that we split names separated by the pair character.
  // The pairs mode must be set manually.
  //
  enum class lexer_mode {normal, value, variable, pairs};

  class lexer: protected butl::char_scanner
  {
  public:
    lexer (std::istream& is, const std::string& name)
        : char_scanner (is), fail (name) {}

    const std::string&
    name () const {return fail.name_;}

    // Note: sets mode for the next token. If mode is pairs, then
    // the second argument specifies the separator character.
    //
    void
    mode (lexer_mode m, char pair_separator = '=')
    {
      next_mode_ = m;
      pair_separator_ = pair_separator;
    }

    lexer_mode
    mode () const {return mode_;}

    // Scanner.
    //
    token
    next ();

  private:
    token
    name (xchar, bool separated);

    // Return true we have seen any spaces. Skipped empty lines don't
    // count. In other words, we are only interested in spaces that
    // are on the same line as the following non-space character.
    //
    bool
    skip_spaces ();

    xchar
    escape ();

    // Diagnostics.
    //
  private:
    struct fail_mark_base: build::fail_mark_base<failed>
    {
      fail_mark_base (const std::string& n): name_ (n) {}

      location_prologue
      operator() (const xchar&) const;

      std::string name_;
    };
    typedef diag_mark<fail_mark_base> fail_mark;

  private:
    fail_mark fail;

    lexer_mode mode_ {lexer_mode::normal};
    char pair_separator_;
    lexer_mode next_mode_ {lexer_mode::normal}; // Switch to for next token.
    lexer_mode prev_mode_; // Return to after current mode expires.
  };
}

#endif // BUILD_LEXER
