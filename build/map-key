// file      : build/map-key -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_MAP_KEY
#define BUILD_MAP_KEY

#include <utility>    // declval()
#include <functional> // hash

namespace build
{
  // Google the "Emulating Boost.MultiIndex with Standard Containers" blog
  // post for deatils.
  //

  template <typename T>
  struct map_key
  {
    mutable const T* p;

    map_key (const T* v = 0): p (v) {}
    bool operator< (const map_key& x) const {return *p < *x.p;}
    bool operator== (const map_key& x) const {return *p == *x.p;}
  };

  template <typename I>
  struct map_iterator_adapter: I
  {
    typedef const typename I::value_type::second_type value_type;
    typedef value_type* pointer;
    typedef value_type& reference;

    map_iterator_adapter () {}
    map_iterator_adapter (I i): I (i) {}

    map_iterator_adapter&
    operator= (I i) {static_cast<I&> (*this) = i; return *this;}

    reference operator* () const {return I::operator* ().second;}
    pointer operator-> () const {return &I::operator-> ()->second;}
  };
}

namespace std
{
  template <typename T>
  struct hash<build::map_key<T>>: hash<T>
  {
    size_t
    operator() (build::map_key<T> x) const
      noexcept (noexcept (declval<hash<T>> () (*x.p)))
    {
      return hash<T>::operator() (*x.p);
    }
  };
}

#endif // BUILD_MAP_KEY
