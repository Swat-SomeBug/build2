// file      : build/parser -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_PARSER
#define BUILD_PARSER

#include <string>
#include <vector>
#include <iosfwd>
#include <utility>   // std::move
#include <exception>


#include <build/path>

namespace build
{
  class scope;

  class token;
  enum class token_type;
  class lexer;

  // The handler must assume the diagnostics has already been issued.
  //
  struct parser_error: std::exception {};

  class parser
  {
  public:
    parser (std::ostream& diag): diag_ (diag) {}

    void
    parse (std::istream&, const path&, scope&);

    // Recursive descent parser.
    //
  private:
    struct name_type
    {
      name_type (std::string t, path d, std::string n)
          : type (std::move (t)), dir (std::move (d)), name (std::move (n)) {}

      std::string type; // Empty if untyped.
      path dir;
      std::string name;
    };

    typedef std::vector<name_type> names;

    void
    parse_clause (token&, token_type&);

    names
    parse_names (token& t, token_type& tt)
    {
      names ns;
      parse_names (t, tt, ns, nullptr, nullptr);
      return ns;
    }

    void
    parse_names (token&, token_type&, names&,
                 const path* dir, const std::string* type);

    // Utilities.
    //
  private:
    token_type
    next (token&, token_type&);

    std::ostream&
    error (const token&);

  private:
    std::ostream& diag_;

    lexer* lexer_;
    const path* path_;
    scope* scope_;
  };
}

#endif // BUILD_PARSER
