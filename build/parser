// file      : build/parser -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_PARSER
#define BUILD_PARSER

#include <string>
#include <iosfwd>
#include <utility> // move()

#include <build/types>
#include <build/token>
#include <build/spec>
#include <build/variable>    // list_value
#include <build/diagnostics>

namespace build
{
  class scope;
  class target;
  class lexer;

  class parser
  {
  public:
    typedef build::names names_type;
    typedef build::variable variable_type;

    parser (): fail (&path_) {}

    // Issue diagnostics and throw failed in case of an error.
    //
    void
    parse_buildfile (std::istream&, const path&, scope& root, scope& base);

    buildspec
    parse_buildspec (std::istream&, const std::string& name);

    token
    parse_variable (lexer&, scope&, std::string name, token_type kind);

    names_type
    parse_export_stub (std::istream& is, const path& p, scope& r, scope& b)
    {
      parse_buildfile (is, p, r, b);
      return std::move (export_value_);
    }

    // Recursive descent parser.
    //
  protected:
    void
    clause (token&, token_type&);

    void
    print (token&, token_type&);

    void
    source (token&, token_type&);

    void
    include (token&, token_type&);

    void
    import (token&, token_type&);

    void
    export_ (token&, token_type&);

    void
    using_ (token&, token_type&);

    void
    define (token&, token_type&);

    void
    if_else (token&, token_type&);

    void
    variable (token&, token_type&, std::string name, token_type kind);

    std::string
    variable_name (names_type&&, const location&);

    names_type
    variable_value (token&, token_type&, const variable_type&);

    names_type
    eval (token&, token_type&);

    // If chunk is true, then parse the smallest but complete, name-wise,
    // chunk of input. Note that in this case you may still end up with
    // multiple names, for example, {foo bar}.
    //
    names_type
    names (token& t, token_type& tt, bool chunk = false)
    {
      names_type ns;
      names (t, tt, ns, chunk, 0, nullptr, nullptr, nullptr);
      return ns;
    }

    void
    names (token&, token_type&,
           names_type&,
           bool chunk,
           std::size_t pair,
           const std::string* prj,
           const dir_path* dir,
           const std::string* type);

    size_t
    names_trailer (token&, token_type&,
                   names_type&,
                   size_t pair,
                   const std::string* prj,
                   const dir_path* dir,
                   const std::string* type);

    // Skip until newline or eos.
    //
    void
    skip_line (token&, token_type&);

    // Skip until block-closing } or eos, taking into account nested blocks.
    //
    void
    skip_block (token&, token_type&);

    // Buildspec.
    //
    buildspec
    buildspec_clause (token&, token_type&, token_type end);

    // Utilities.
    //
  protected:

    // Switch to a new current scope. Note that this function might
    // also have to switch to a new root scope if the new current
    // scope is in another project. So both must be saved and
    // restored.
    //
    void
    switch_scope (const dir_path&);

    void
    process_default_target (token&);

    // Enter buildfile as a target.
    //
    void
    enter_buildfile (const path&);

    // Lexer.
    //
  protected:
    token_type
    next (token&, token_type&);

    token_type
    peek ();

    const token&
    peeked () const
    {
      assert (peeked_);
      return peek_;
    }

    // Diagnostics.
    //
  protected:
    const fail_mark<failed> fail;

  protected:
    const std::string* path_; // Path processed by diag_relative().
    lexer* lexer_;
    target* target_; // Current target, if any.
    scope* scope_;   // Current base scope (out_base).
    scope* root_;    // Current root scope (out_root).
    target* default_target_;
    names_type export_value_;

    token peek_ {token_type::eos, false, 0, 0};
    bool peeked_ {false};
  };
}

#endif // BUILD_PARSER
