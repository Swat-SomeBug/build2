// file      : build/parser -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Tools CC
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD_PARSER
#define BUILD_PARSER

#include <string>
#include <vector>
#include <iosfwd>
#include <utility>   // std::move

#include <build/path>
#include <build/diagnostics>

namespace build
{
  class scope;

  class token;
  enum class token_type;
  class lexer;

  class parser
  {
  public:
    // Issues diagnostics and throws failed in case of an error.
    //
    void
    parse (std::istream&, const path&, scope&);

    // Recursive descent parser.
    //
  private:
    struct name_type
    {
      name_type (std::string t, path d, std::string n)
          : type (std::move (t)), dir (std::move (d)), name (std::move (n)) {}

      std::string type; // Empty if untyped.
      path dir;
      std::string name;
    };

    typedef std::vector<name_type> names;

    void
    parse_clause (token&, token_type&);

    names
    parse_names (token& t, token_type& tt)
    {
      names ns;
      parse_names (t, tt, ns, nullptr, nullptr);
      return ns;
    }

    void
    parse_names (token&, token_type&, names&,
                 const path* dir, const std::string* type);

    // Utilities.
    //
  private:
    token_type
    next (token&, token_type&);

    // Diagnostics.
    //
  private:
    struct fail_mark_base: build::fail_mark_base<failed>
    {
      location_prologue
      operator() (const token&) const;

      const path* path_;
    };
    typedef diag_mark<fail_mark_base> fail_mark;

  private:
    fail_mark fail;

    lexer* lexer_;
    scope* scope_;
  };
}

#endif // BUILD_PARSER
