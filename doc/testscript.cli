// file      : doc/testscript.cli
// copyright : Copyright (c) 2014-2016 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

"\name=build2-testscript-language"
"\subject=Testscript language"
"\title=Testscript Language"

// NOTES
//
// - Maximum <pre> line is 70 characters.
//

// @@ Testscript vs testscript
//

"
\h0#preface|Preface|

This document describes the \c{build2} Testscript language. It begins with an
introduction that first discusses the motivation behind having a separate
domain-specific language and then continues to introduce a number of
Testscript concept with examples. The remainder of the document provides a
more formal description of the language, including its integration into the
build system, lexical structure, compilation and execution model, as well as
grammar and semantics.

In this document we use the term \"Testscript\" (capitalized) to refer to the
Testscript language. Just \"testscript\" means some code written in this
language. For example: \"We can pass addition information to testscripts using
target-specific variables.\" Finally, \c{testscript} refers to the specific
file name.

We also use the equivalent distinction between \"Buildfile\" (language),
\"buildfile\" (code), and \c{buildfile} (file).

\h1#intro|Introduction|

Testscript is a domain-specific language for running tests. Traditionally, if
your testing requires varying input or analyzing output, you would use a
scripting language, for instance Bash. This has a number of drawbacks.
Firstly, this approach is usually not portable (there is no Bash on
Windows \i{out of the box}). It is also hard to write concise tests in a
general-purpose scripting language. The result is often a test suite that has
grown incomprehensible which is a major problem since now everyone dreads
adding new tests. Finally, it is hard to run such tests in parallel without a
major effort (for example, having a separate script for each test).

Testscript vaguely resembles Bash and is optimized for concise test
description by focusing on the following functionality:

\ul|

\li|Supplying input via command line and \c{stdin}.|

\li|Comparing to expected exit status.|

\li|Comparing to expected output for both \c{stdout} and \c{stderr}.|

\li|Setup/teardown commands and automatic file/directory cleanup.|

\li|Simple (single-command) and compound (multi-command) tests.|

\li|Test groups with common setup/teardown.|

\li|Test isolation for parallel execution.|

\li|Test documentation.||

Note that Testscript is a \i{test runner}, not a testing framework for a
particular programming language. It does not concern itself with how the test
executables themselves are implemented. As a result, it is mostly geared
towards functional testing but can also be used for unit testing if external
input/output is required. Testscript is an extension of the \c{build2} build
system and is implemented by its \c{test} module.

As an illustration, let's test a \"Hello, World\" program. For a simple
implementation the corresponding \c{buildfile} might look like this:

\
exe{hello}: cxx{hello}
\

We also assume that the project's \c{bootstrap.build} loads the \c{test}
module which implements the execution of the testscripts.

To start, we create an empty file called \c{testscript}. To indicate that a
testscript file tests a specific target we simply list it as a target's
prerequisite, for example:

\
exe{hello}: cxx{hello} test{testscript}
\

Let's assume our \c{hello} program expects us to pass the name to greet as
a command line argument. And if we don't pass anything, it prints usage and
terminates with a non-zero exit status. Let's test this by adding the
following line to the \c{testscript} file:

\
$* != 0
\

While it sure is concise, it may look cryptic without some explanation. When
the \c{test} module runs tests, it passes to each testscript the target path
of which this testscript is a prerequisite. So in our case the testscript will
receive the path to our \c{hello} executable. Also, the buildfile can pass
along additional options and arguments. And inside the testscript, all of this
(target path, options, and arguments) are bound to the \c{$*} variable. So in
our case, if we expand the above line, it will be something like this:

\
/tmp/hello/hello != 0
\

Or, if we are on Windows, something like this:

\
C:\projects\hello\hello.exe != 0
\

The remainder of the command (\c{!= 0}) is the exit status check. If we don't
specify it, then the test is expected to exit with zero status (which is
equivalent to specifying \c{== 0}).

If we run our test, it will pass provided our program behaves as expected.
One thing our test doesn't verify, however, is the usage that gets
printed. Let's fix that assuming this is the code that prints it:

\
cerr << \"usage: \" << argv[0] << \" <name>\" << endl;
\

In testscripts you can compare output to the expected result for both
\c{stdout} and \c{stderr}. We can supply the expected result as either
\i{here-string} or \i{here-document}. The here-string approach works
best for short, single-line output and we will use it for another test
in a minute. For this test let's use here-document since the usage
line is somewhat long (not really, but play along):

\
$* 2>>EOE != 0
usage: $0 <name>
EOE
\

Let's decrypt this: the \c{2>>EOE} is a here-document redirect with \c{2}
being the \c{stderr} file descriptor and \c{EOE} is the string we chose to
mark the end of here-document (stands for End-Of-Error). Next comes the
here-document fragment. In our case it has only one line but it could have
several. Note also that we can expand variables in here-document fragments.
You probably have guessed that \c{$0} expands to the target path. Finally,
we have the here-document end marker.

Now when executing this test the \c{test} module will check two things: it
will compare the \c{stderr} output to the expected result using the \c{diff}
tool and it will make sure the test exits with a non-zero status.

Now that we have tested the failure case, let's test the normal functionality.
While we could have used here-document, in this case here-string will be more
concise:

\
$* World >\"Hello, World!\"
\

It's also a good idea to document our tests. Testscript has a formalized test
description that can capture the test id, summary, and details. All three
components are optional and how thoroughly you document your tests is up to
you.

Description lines precede the test command, start with a colon (\c{:}), and
have the following layout:

\
: <id>
: <summary>
:
: <details>
\

The recommended format for \c{<id>} is \c{<keyword>-<keyword>...} with at
least two keywords. The id is used in diagnostics as well as to run individual
tests. The recommended style for \c{<summary>} is that of the \c{git(1)}
commit summary. The detailed description is free-form. Here are some examples:

\
# Only id.
#
: missing-name

# Only summary.
#
: Test handling of missing name

# Both id and summary.
#
: missing-name
: Test handling of missing name

# All three: id, summary, and a detailed description.
#
: missing-name
: Test handling of missing name
:
: This test makes sure the program detects that the name to greet
: was not specified on the command line and both prints usage and
: exits with non-zero status.
\

The recommended way to come up with an id is to distill the summary to its
essential keywords by removing generic words like \"test\", \"handle\", and so
on. If you do this, then both the id and summary will convey essentially the
same information. As a result, to keep things concise, you may choose to drop
the summary and only have the id.

Either the id or summary (but not both) can alternatively be specified inline
in the test command after a colon (\c{:}), for example:

\
$* != 0 : missing-name
\

Similar to handling output, Testscript provides a convenient way to supply
input to test's \c{stdin}. Let's say our \c{hello} program recognizes the
special \c{-} name as an instruction to read the names from \c{stdin}. This
is how we could test this functionality:

\
$* - <<EOI >>EOO : stdin-names
Jane
John
EOI
Hello, Jane!
Hello, John!
EOO
\

As you might have suspected, we can also use here-string to supply \c{stdin},
for example:

\
$* - <World >\"Hello, World!\" : stdin-name
\

Let's say our \c{hello} program has a configuration file that captures custom
name to greeting mappings. A path to this file can be passed as a second
command line argument. To test this functionality we first need to create a
sample configuration file. We do these kind of not-test actions with \i{setup}
and \i{teardown} commands, for example:

\
+cat <<EOI >>>hello.conf;
John = Howdy
Jane = Good day
EOI
$* Jane hello.conf >\"Good day, Jane!\" : config-greet
\

The setup commands start with the plus sign (\c{+}) while teardown \- with
minus (\c{-}). Notice also the semicolon (\c{;}) at the end of the setup
command: it indicates that the following command is part of the same test \-
what we call a multi-command or \i{compound} test.

Other than that it should all look familiar. You may be wondering why we don't
have a teardown command that removes \c{hello.conf}? It is not necessary
because this file will be automatically registered for automatic cleanup that
will happen at the end of the test. We can also register our own files and
directories for automatic cleanup. For example, if the \c{hello} program
created the \c{hello.log} file on unsuccessful runs, then here is how we could
have cleaned it up:

\
$* &hello.log != 0
\

What if we wanted to run two tests for this configuration file functionality?
For example, we may want to test the custom greeting as above but also make
sure the default greeting is not affected. One way to do this would be to
repeat the setup command in each test. But, as you can probably guess, there
is a better way to do it: testscripts can define test groups. For example:

\
: config
{
  conf = hello.conf

  +cat <<EOI >>>$conf
  John = Howdy
  Jane = Good day
  EOI

  $* John ../$conf >\"Howdy, John!\" : custom-greet
  $* Jack ../$conf >\"Hello, Jack!\" : default-greet
}
\

@@ Need to explain why ../

A test group is a scope that contains several test/setup/teardown commands.
Variables set inside a scope (like our \c{conf}) are only in effect until the
end of the scope. Plus, setup and teardown commands that are not part of any
test (notice the lack of \c{;} after \c{+ cat}) are associated with the scope;
their automatic cleanup only happens at the end of the scope (so our
\c{hello.conf} will only be removed after all the tests in the group have
completed).

Note also that a scope can have a description. In particular, assigning a
test group an id allows us to run tests only from this specific group.

We can also use scopes for individual tests. For example, if we need to
set a test-local variable:

\
: config-greet
{
  conf = hello.conf
  +cat <\"Jane = Good day\" >>>$conf;
  $* Jane $conf >\"Good day, Jane!\"
}
\

We can exclude sections of a testscript from execution using the \c{.if},
\c{.elif}, and \c{.else} directives. For example, we may need to omit a
test if we are running on Windows (notice the last line with just the
dot \- it marks the end of the \c{.if} body):

\
.if ($cxx.target.class != windows)
  $* Jane /dev/null >\"Hello, Jane!\" : config-empty
.end
\

You may have noticed that in the above example we referenced the
\c{cxx.target.class} variable as if we were in a buildfile. We could do that
because the testscript variable lookup continues in the buildfile starting
from the testscript target and continuing with the standard buildfile variable
lookup. In particular, this means we can pass arbitrary information to
testscripts using target-specific variables. For example, this how we can
move the above platform test to \c{buildfile}:

\
# buildfile

exe{hello}: cxx{hello} test{testscript}

test{*}: windows = ($cxx.target.class == windows)
\

\
# testscript

.if! $windows
  $* Jane /dev/null >\"Hello, Jane!\" : config-empty
.end
\

To conclude, let's put all our tests together so that we can have a complete
picure:

\
$* != 0                     : missing-name
$* World >\"Hello, World!\"   : command-name
$* - <<EOI >>EOO            : stdin-names
Jane
John
EOI
Hello, Jane!
Hello, John!
EOO

: config
{
  conf = hello.conf

  +cat <<EOI >>>$conf
  John = Howdy
  Jane = Good day
  EOI

  $* John ../$conf >\"Howdy, John!\"  : custom-greet
  $* Jack ../$conf >\"Hello, Jack!\"  : default-greet
.if! $windows
  $* Jane /dev/null >\"Hello, Jane!\" : config-empty
.end
}
\

@@ Add test.redirects?

@@ Maybe allow variables in-between test lines (;)? Will have to recognize
   semicolon in variable value.

@@ Maybe $~ for test temp directory.

@@ temp directory structure (why ../)?

@@ how to run individual tests/groups?

@@ how to preserve test output

@@ term: 'test working directory'

\h1#integration|Build System Integration|

The \c{build2} \c{test} module provides the ability to run an executable
target as a test, optionally passing options and arguments, providing
\c{stdin} input, as well as comparing the \c{stdout} output to the expected
result. For example:

\
exe{xml-parser}: test.options = --strict
exe{xml-parser}: test.input = test.xml
exe{xml-parser}: test.output = test.out
\

This works well for simple, single-run tests. In contrast the testscript
approach allows you to perform multiple test runs of potentially multi-command
(compound) tests that can perform setup/teardown actions. It also provides
concise mechanisms for commonly used test steps such as supplying input
as well as comparing output and exit status.

The integration of testscripts into buildfiles is done using the standard
\i{target-prerequisite} mechanism. In this sense, a testscript is a
prerequisite that describes how to test the target similar to how, for
example, the \c{INSTALL} file describes how to install it. For example:

\
exe{xml-parser}: test{testscript} doc{INSTALL README}
\

By convention the testscript file should be either called \c{testscript} if
you only have one or have the \c{.test} extension, for example,
\c{basics.test}. The \c{test} modules registers the \c{test{\}} target type
for testscript files.

A testscript prerequisite can be specified for any target. For example, if
our directory contains a bunch of shell scripts that we want to test together,
then it makes sense to specify the testscript prerequisite for the directory
target:

\
./: test{basics}
\

During variable lookup if a variable is not found in a testscript, then its
search continues in the buildfile starting from the testscript target. This
means a testscript can \"see\" all the existing buildfile variables and
we can use target-specific variables to pass additional information, for
example:

\
# testscript

.if ($cxx.target.class == windows)
  foo = $bar
\

\
# buildfile

test{testscript}@./: bar = baz
\

Additionally, a number of \c{test.*} variables are reused to pass specific
information to testscripts. Unless set manually as a testscript
target-specific variable, the \c{test} variable is automatically set to the
target path being tested. For example, given this \c{buildfile}:

\
exe{xml-parser}: test{testscript}
\

The value of \c{test} inside the testscript will be the absolute path to the
\c{xml-parser} executable.

The other two special variables are \c{test.options} and \c{test.arguments}.
You can use them to pass additional options/arguments to your test scripts
and together with \c{test} they form the test target command line which is
bound to a number of read-only variable aliases:

\
$* - the complete {$test $test.options $test.arguments} command line
$0 - $test
$N - (N-1)-th element in the {$test.options $test.arguments} array
\

Note that these aliases are read-only; if you need to modify any of the
values then you should use the original variable names, for example:

\
test.options += --strict

$* <\"not xml\" != 0
\

A testscript would normally contain multiple tests and sometimes it is
desirable to only run a specific test or a group of tests. For example, you
may be debugging a failing tests and would like to re-run it. Each test and
test group in a testscript has an id. As a result each test has an \i{id path}
that uniquely identifies it. The id path starts with the testscript file name
(corresponds to the id of the implied outermost test group, as described
below), may include a number of intermediate test group ids, and ends with the
test id. The ids in a path are separated with a forward slash (\c{/}). Note
that this also happens to be the filesystem path to the temporary directory
where the test is executed (again, as discussed below). As an example,
consider the following testscript file called \c{basics.test}:

\
$* foo ; foo

: fox
{{
   $* fox bar ; bar
   $* fox baz ; baz
}}
\

The id paths for the three test will then be:

\
basics/foo
basics/fox/bar
basics/fox/baz
\

To only run individual tests, test groups, or testscript files we can specify
their id paths in the \c{config.test} variable, for example:

\
$ b test config.test=basics     # Run all tests in basics.test.
$ b test config.test=basics/fox # Run bar and baz.
$ b test config.test=basics/foo # Run foo.
$ b test \"config.test=basics/foo basics/fox/bar\" # Run fox and bar.
\

\h1#lexical|Lexical Structure|

Testscript is a line-oriented language with a context-dependent lexical
structure. It \"borrows\" several building blocks (for example, variable
expansion) from the Buildfile language. In a sense, testscripts are
specialized (for testing) continuations of buildfiles.

Except in here-document fragments, leading whitespaces and blank lines are
ignored except for the line/column counts. A non-empty testscript must
end with a newline.

The backslash (\c{\\}) character followed by a newline signals the line
continuation. Both this character and the newline are removed (note: not
replaced with a whitespace) and the following line is read as if it was part
of the first line. Note that \c{'\\'} followed by EOF is invalid. For example:

\
$* foo | \
$* bar
\

An unquoted and unescaped \c{'#'} character starts a comments; everything from
this character until the end of line is ignored. For example:

\
# Setup foo.
$* foo

$* bar # Setup bar.
\

Note that there is no line continuation in comments; the trailing \c{'\\'} is
ignored except in one case: if the comment is just \c{'#\\'} followed by the
newline, then it starts a multi-line comment that spans until the closing
\c{'#\\'} comment is encountered. For example:

\
#\
$* foo
$* bar
#\
\

Similar to Buildfile, the Testscript language supports two types of quoting:
single (\c{'}) and double (\c{\"}). Both can span multiple lines.

The single-quoted string does not recognize any escape sequences (not even for
the single quote itself or line continuations) with all the characters taken
literally until the closing single quote is encountered.

The double-quoted string recognizes escape sequences (including line
continuations) as well as expansions of variables and evaluations of contexts.
For example:

\
foo = FOO
bar = \"$foo ($foo == FOO)\" # 'FOO true'
\

Characters that have special syntactic meaning (for example \c{'$'}) can be
escaped with a backslash (\c{\\}) to preserve their literal meaning (to
specify literal backslash you need to escape it as well). For example:

\
foo = \$foo\\bar # '$foo\bar'
\

Note that quoting could often be a more readable way to achieve the same
result, for example:

\
foo = '$foo\bar'
\

Inside double-quoted strings only the \c{\"\\$(} character set needs to be
escaped.

A character is said to be \i{unquoted} and \i{unescaped} if it is not escaped
and is not part of a quoted string. A token is said to be unquoted and
unescaped if all its characters are unquoted and unescaped.

The lexical structure of the remainder of a line (that is, the \i{context}) is
determined by the leading (unquoted and unescaped) character after ignoring
any (unquoted and unescaped) leading whitespaces. The following characters are
context-introducing.

\
':'  - description line
'.'  - directive line
'{'  - block start
'}'  - block end
'+'  - setup command line
'-'  - teardown command line
\

For the here-document lines the context is implied by the preceding line. If
none of the above determinants apply, then the line is either a variable
assignment or a test command line. Distinguishing between the two is performed
during parsing and is described below.


\h1#grammar|Grammar and Semantics|

\h#grammar-notation|Notation|

The formal grammar of the Testscript language is specified using an EBNF-like
notation with the following elements:

\
foo: ...   - production rule
foo        - non-terminal
<foo>      - terminal
'foo'      - literal
foo*       - zero or more multiplier
foo+       - one or more multiplier
foo?       - zero or one multiplier
foo bar    - concatenation (foo then bar)
foo | bar  - alternation   (foo or bar)
(foo bar)  - grouping
{foo bar}  - concatenation in any order (foo then bar or bar then foo)
foo \
bar        - line continuation
# foo      - comment
\

Rule right-hand-sides that start on a new line describe the line-level syntax
and ones that start on the same line describes the syntax inside the line. If
a multiplier appears in from on the line then it specifies the number of
repetitions for the whole line. For example, from the following three rules,
the first describes a single line of multiple literals (such as
\c{'foofoofoo'}), the second \- multiple lines of a single literal (such as
\c{'foo\\nfoo\\nfoo'}), and the third \- multiple lines of multiple literals
(such as \c{'foo\\nfoofoo\\nfoofoofoo'}).

\
text-line: 'foo'+

text-lines:
  +'foo'

text-lines:
  +('foo'+)
\

A newline in the grammar matches any standard newline separator sequence
(CR/LF combinations). An unquoted space in the grammar matches zero or more
non-newline whitespaces (spaces and tabs). A quoted space matches exactly one
non-newline whitespace. Note also that in some cases components within lines
may not be whitespace-separated in which case they will be written without any
spaces between them, for example:

\
foo: 'foo' ';'    # \"foo;\" or \"foo ;\" or \"foo      ;\"
bar: 'bar'';'     # \"bar;\"
baz: 'baz'' '+';' # \"baz ;\" or \"baz      ;\"

fox: bar''bar     # \"bar;bar;\"
\

You may also notice that several production rules below end with \c{-line}
while potentially spanning several physical lines. In such cases they
represent \i{logical lines}, for example, a test, its description, and its
here-document fragments.

\h#grammar-all|Grammar|

@@ Move directives last?

\
script:
  scope-body

scope-body:
  *setup
  *(scope|test|include)
  *teardown

setup:
  variable-line|setup-line

teardown:
  variable-line|teardown-line

scope:
  description?
  '{'
  scope-body
  '}'

test:
  description?
  *((variable-line|test-line) ';')
  test-line (':' <text>)?

include: '.include'(' '+'--once')*(' '+<path>)*

description:
  +(':' <text>)

variable-line: <variable> ('='|'+='|'=+') value-attributes? <value>
value-attributes: '[' <key-value-pairs> ']'

setup-line:    '+' command-expr
teardown-line: '-' command-expr
test-line:         command-expr

command-expr: command-pipe (('||'|'&&') command-pipe)*
command-pipe: command ('|' command)*

command: <path>(' '+(<arg>|redirect|cleanup))* command-exit?
  *here-document

redirect: stdin|stdout|stderr

stdin:  '0'?(in-redirect)
stdout: '1'?(out-redirect)
stderr: '2'(out-redirect)

in-redirect:  '<-'|\
              '<+'|\
              ('<'|'<:') <text>|\
              ('<<'|'<<:') <here-end>|\
              '<<<' <file>

out-redirect: '>-'|\
              '>+'|\
              '>&' ('1'|'2')|\
              ('>'|'>:') <text>|\
              ('>>'|'>>:') <here-end>|\
              ('>>>'|'>>>&') <file>

cleanup: ('&'|'&!'|'&?') (<file>|<dir>)

command-exit: ('=='|'!=') <exit-status>

here-document:
  *<text>
  <here-end>
\

Note that file descriptors must not be separated from the redirect operators
with whitespaces. And if leading text is not separated from the redirect
operators, then it is expected to be a file descriptor. As an example, the
first command below has \c{2} as an argument and redirects \c{stdout}, not
\c{stderr}. While the second is invalid since \c{a1} is not a valid file
descriptor.

\
$* 2 >!
$* a1>!
\

In merge redirects the left-hand-side descriptor (implied or explicit) must
not be the same as the right-hand-side. Having both merge redirects at the
same time is illegal.

Here-line is like double-quoted string but recognizes newlines.

It is an error to specify both leading and trailing descriptions.

\h#include|Inclusion|

While in the grammar the \c{include} directive is shown to only appear
interleaving with scopes and tests, it can be used anywhere in the scope
body. It can also contain several parts of a scope, for example, setup and
test lines.

The \c{--once} option signals that files that have already been included in
this scope should not be included again. The implementation is not required to
handle links when determining if two paths are to the same file. Relative
paths are assumed to be relative to the including testscript.

Note that \c{include} is a directive, not a command. It is performed during
parsing before any command is executed or testscript variable assigned. You
can, however, use variables assigned in the buildfile. For example:

\
include --once common-$(cxx.target.class).test
\

\
script:
  (script-scope|script-line)*

script-scope:
  description-line?
  '{'
  script
  '}'

script-line:
  directive-line|variable-line|test-line|setup-line|teardown-line

description-line: ':' <text>
  (':' <text>)*

directive-line:
  include|if-else

include: '.include'( <path>)+

if-else: ('.if'|'.if!') <condition>
  script
  elif*
  else?
  '.end'

elif: ('.elif'|'.elif!') <condition>
  script

else: '.else'
  script

variable-line: <variable> ('='|'+='|'=+') value-attributes? <value>
value-attributes: '[' <key-value-pairs> ']'

test-line:
  description-line?
  command-expr command-exit? (';'|(':' <text>))?
  here-document*

command-exit: ('=='|'!=') <exit-status>

setup-line: '+' command-expr ';'?
  here-document*

teardown-line: '-' command-expr ';'?
  here-document*

command-expr: command-pipe (('||'|'&&') command-pipe)*
command-pipe: command ('|' command)*

command: <path> (' '+ <arg>)* {stdin? stdout? stderr? cleanup*}

stdin:      ('<!'|\
             '<?'|\
             '<' <text>|\
             '<<' <here-end>|\
             '<<<' <file>)

stdout:     ('>!'|\
             '>?'|\
             '>&' '2'|\
             '>' <text>|\
             '>>' <here-end>|\
             ('>>>'|'>>>&') <file>)

stderr: '2' ('>!'|\
             '>?'|\
             '>&' '1' |\
             '>' <text>|\
             '>>' <here-end>|\
             ('>>>'|'>>>&') <file>)

cleanup: '&' (<file>|<dir>)

here-document:
  <text>*
  <here-end>
\


\h#grammar-script|Script|

\
script:
  (script-scope | script-line)*
\

A testscript file is a sequence of scopes and (logical) lines.

\h#grammar-scope|Scope|

\
script-scope:
  description-line?
  '{'
  script
  '}'
\

A block establishes a nested variable scope and a cleanup context. Any
variables set within the block will only have effect until the end of the
block. All registered cleanups are triggered at the end of the block.

Additionally, entering a block triggers the creation of a nested temporary
directory with the test/group id (see below) as its name. This directory then
becomes the current working directory (\c{CWD}). Unless instructed otherwise,
this temporary directory is removed at the end of the block and the previous
\c{CWD} value is restored. (@@ Should we expect it to be empty, i.e., no
unexpected output from the test?).

Test and test group blocks have the same semantics except that in a test block
each test line is considered to be part of the same test while in the test
group each test line is treated as an individual test. Individual test lines
in a group are treated \i{as if} they were in a test block consisting of just
that line. In particular, this means that a nested temporary directory is also
created for such individual tests and cleanup happens immediately after
executing the test line.

While test group blocks can contain other test group and test blocks, test
blocks cannot contain nested blocks of any kind.

A testscript execution starts in \c{out_base} as \c{CWD} and \i{as if} in an
implicit test group block with the testscript file name (without the
extension) as this group's id.

For example, consider the following testscript file which we assume is called
\c{basics.test}:

\
: group1
{{
  foo = bar

  + setup1
  + setup2 &out-setup2

  test1 &out-test1 ; test1

  : test2
  {
    bar = baz

    test2a $baz &out-test2
    test2b <out-test2
  }

  test3 $foo ; test3

  - teardown2
  - teardown1
}}
\

Below is its annotated version that shows all the \i{as if} transformations
as well as various actions performed during its execution:

\
# set CWD=$out_root/

: basics
{{ # Create basics/ temporary subdirectory, set CWD=basics/

  : group1
  {{ # Create group1/ temporary subdirectory, set CWD=group1/

    foo = bar

    + setup1
    + setup2 &out-setup2

    : test1
    { # Create test1/ temporary subdirectory, set CWD=test1/

      test1 &out-test1

    } # Remove out-test1, remove test1/, set CWD=group1/

    : test2
    { # Create test2/ temporary subdirectory, set CWD=test2/

      bar = baz

      test2a $baz &out-test2
      test2b <out-test2

    } # Variable bar is no longer in effect
      # Remove out-test2, remove test2/, set CWD=group1/

    : test3
    { # Create test3/ temporary subdirectory, set CWD=test3/

      test3 $foo

    } # Remove test3/, set CWD=group1/

    - teardown2
    - teardown1

  }} # Variable foo is no longer in effect
     # Remove out-setup2, group1/, set CWD=basics/

}} # Remove basics/, set CWD=$out_root/
\

Because of this nested directory structure, a test can use \c{..}-based
relative paths to refer to, for example, a file created by a group's setup
command. For example:

\
{{
  + setup &out-setup

  test ../out-setup
}}
\


\h#grammar-line|Line|

\
script-line:
  directive-line | \
  variable-line  | \
  test-line | setup-line | teardown-line
\

A testscript line is either a directive, a variable assignment, a
setup/teardown command, or a test command.

To distinguish between the variable assignment and test command line the
parsing and expansion is performed in the \i{chunking} mode, that is, the
parser parses a minimum amount of semantically complete input and stops.

If parsing the first chunk of the input resulted in a single simple name and
the following lexer token is one of \c{=}, \c{+=}, or \c{=+}, then this line
is treated as a variable assignment. Otherwise, it is a test command line.

Similar to the Buildfile language, this semantics supports indirect/computed
variable names, for example:

\
foo = bar
$bar = baz
\

\h#grammar-description|Description|

\
description-line: ': '<text>
  (': '<text>)*
\

Description lines start with a colon (\c{:}) and are used to document tests
(either single-line or compound) as well as test groups. In a sense, they are
formalized comments.

By convention the description has the following format with all three
components being optional.

\
: <id>
: <summary>
:
: <details>
\

If the first line in the description does not contain any whitespaces, then it
is assumed to be the test or test group id. If the next line is followed by a
blank line, then it is assume to be the test or test group summary. After the
blank line come optional details which are free-form.

If an id is not specified then it is automatically derived from the test or
test group location. If the test or test group is contained directly in the
top-level testscript file, then just its start line number is used as an id.
Otherwise, if the test or test group reside in an included file, then the
start line number (inside the included file) is prefixed with the line number
of the \c{.include} directive followed by the included file name (without the
extension) in the form \c{<line>-<file>-}. This process is repeated
recursively for nested inclusion.

The start line for a block (either test or group) is the line containing
opening brace (\c{{}) and for a simple test \- the test line itself.

\h#grammar-directives|Directives|

\
directive-line:
  include
  if-else
\

All directive lines start with a leading dot (\c{.}). To specify a
non-directive line that starts with a dot you can either escape or quote it,
for example:

\
\.include
'.include'
\

\h2#grammar-directives-include|\c{.include}|

\
include: '.include' (<path> )+
\

The \c{include} directive includes one or more testscript files into
another. If the specified path is not absolute, then it is interpreted as
being relative to the including file. The semantics of inclusion is \i{as if}
the contents of the included file appeared directly in the including file
except for deriving test/group ids and displaying locations in diagnostics.

The reminder of the line after the \c{'.include'} word is expanded as a
Buildfile variable value.


\h2#grammar-directives-if-else|\c{.if} \c{.else}|

\
if-else: ('.if' | '.if!') <condition>
  script
  elif*
  else?
  '.end'

elif: ('.elif' | '.elif!') <condition>
  script

else: '.else'
  script
\

The \c{if-else} directives allow for conditional exclusion of testscript
fragments. The body of the \c{if-else} directive can be either a single
(logical) line, a single block, or multiple lines/blocks. For example:

\
.if ($foo == FOO)
  bar = BAR

.if ($cxx.target.class != windows)
  $* foo

.if ($cxx.target.class != windows)
  {
    $* foo
    $* bar
  }

.if ($foo == FOO)
.{
  $* foo

  bar = BAR
  baz = BAZ

  {
    $* $bar
    $* $baz
  }
.}
\

Note that \c{if-else} operates on logical lines/blocks, for example:

\
.if ($foo == FOO)
  : foo-bar
  : Test foo bar combination
  $* foo bar >>EOO
  foo
  bar
  EOO


.if ($foo == FOO)
  : foo-bar
  : Test foo bar combination
  : foo-bar
  {
    $* foo
    $* bar
  }
\

The reminder of the line after the \c{'.if'} and \c{'.elif'} words is expanded
as a Buildfile variable value and should evaluate to either \c{'true'} or
\c{'false'} text literals.

\h#grammar-variable|Variable Assignment|

\
variable-line: <variable> ('=' | '+=' | '=+') value-attributes? <value>

value-attributes: '[' <key-value-pairs> ']'
\

The Testscript variable assignment semantics is equivalent to Buildfile except
that \c{<value>} is expanded as \"strings\", not \"names\" (@@ clarify) and
the default value type is \c{strings}. Note that unlike Buildfile no variable
attributes are supported.

\h#grammar-test|Test|

\
test-line:
  description-line?
  command-expr command-exit? (';' | ':' <text>)?
  here-document*

command-exit: ('==' | '!=') <exit-status>
\

The test command line can specify an optional exist status check. If omitted,
then the test is expected to succeed (0 exit status).

Variable expansion and context evaluation is performed (using chunked parsing)
in \c{command-expr} and \c{command-exit} but not in the inline test
description.

\h#grammar-setup-teardown|Setup/Teardown|

\
setup-line: '+' command-expr ';'?
  here-document*

teardown-line: '-' command-expr ';'?
  here-document*
\

The setup and teardown command lines are similar to the test command line
except that they cannot have a test description or exit status check (they are
always expected to succeed). The main motivation for distinguishing between
test and setup/teardown commands is the ability to ignore the teardown
commands in order to preserve the setup of test. For example, of a failed test
that you are debugging. Also, the setup/teardown and test commands are shown
at different verbosity levels (\c{3/-V} and \c{2/-v} respectively).

Setup and teardown commands associeted with the test group are executed
sequenctially in the order specified.

\h#grammar-command-expr|Command Expression|

\
command-expr: command-pipe (('||' | '&&') command-pipe)*
\

Multiple commands can be combination with AND and OR operators. Note that the
evaluation order is always from left to right (left-associative) and both
operators have the same precedence and are short-circuiting. Note, however,
that short-circuiting does not apply to variable expansion.

The result of the expression is the exit status of the last \c{command-pipe}
executed.


\h#grammar-command-pipe|Command Pipe|

\
command-pipe: command ('|' command)*
\

Commands can also be combined with a pipe. All the piped commands except that
last are expected to succeed with the last command's exit status being the
result of \c{command-pipe}.

\h#grammar-command|Command|

\
command: <path> <arg>* {stdin? stdout? stderr? merge? cleanup*}
\

A command starts with a command path following by options and arguments, if
any. We can also redirect/merge standard streams as well as register for
automatic cleanup files and directories that may be created by the command.
Note that redirects, merge, and cleanups can appear in any order but must
come after the arguments.

\h#grammar-redirect-merge-cleanup|Redirect, Merge, Cleanup|

\
stdin:  '0'?('<'<text> | '<<'<here-end> | '<<<'<file>     | '<!' | '<?')
stdout: '1'?('>'<text> | '>>'<here-end> | '>>>''&'?<file> | '>!' | '>?')
stderr: '2'('>'<text>  | '>>'<here-end> | '>>>''&'?<file> | '>!' | '>?')

merge: '1>&2' | '2>&1'

cleanup: '&'(<file> | <dir>)
\

The \c{stdin} stream data can come from a pipe, string, the here-document
fragment, file, or \c{/dev/null} (\c{<!}). Specifying both pipe and redirect
is an error.

If no \c{stdin} redirect is specified and the test tries to read any data, it
is considered to have failed. If you need to allow reading from the default
\c{stdin} (for instance if the test is really an example), specify \c{<?}.

The \c{stdout} and \c{stderr} stream data can go to a pipe (\c{stdout} only),
file (append if \c{>>>&}), or \c{/dev/null} (\c{>!}). It can also be
compared to a string or the here-document fragment. For \c{stdout} specifying
both pipe and redirect is an error. If no explicit \c{stderr} redirect is
specified and the test is expected to fail (non-zero exit status), then an
implicit \c{2>!} redirect is assumed.

If no \c{stdout} or \c{stderr} redirect is specified and the test tries to
write any data to either stream, it is considered to have failed. If you need
to allow writing to the default \c{stdout} or \c{stderr}, specify \c{>?} and
\c{2>?}, respectively.

We can also merge \c{stderr} to \c{stdout} (\c{2>&1}) or vice versa
(\c{1>&2}).

If a command creates extra files or directories then we can register them for
automatic cleanup at the end of the test. Files mentioned in redirects are
registered automatically.

Note that unlike shell no whitespaces around \c{<} and \c{>} redirects
or after the \c{&} cleanups are allowed.

A here-document redirect must be specified \i{literally} on test command
line. Specifically, it must not be the result of a variable expansion or
context evaluation, which rarely makes sense anyway since the following
here-document fragment itself cannot be the result of the
expansion/evaluation either; in a sense they both are part of the syntax.

This requirement is imposed in order to be able to skip test lines and their
associated here-document fragments in the \c{if-else} directives without
performing any expansions/evaluations (which may not be valid).

The skipping procedure for a line that is either a variable assignment or a
test command is as follows: The line is lexed until the newline or EOF which
checking each token either for one of the variable assignment operators or
here-document redirects. If both kinds are present then this is an ambiguity
error which can be resolved by quoting either of the token, depending on the
desired semantics (variable assignment or test command). Otherwise, all the
here-document redirects are noted and the corresponding number of here-document
fragments is skipped (which \c{here-end} match/order validation).

Note also that this procedure is applied even in case of \c{if-else} with
\c{directive-block} since the block end (\c{.\}}) may appears literally in
one of the here-document fragments.

\h#grammar-here-document|Here-Document|

\
here-document:
  <text>*
  <here-end>
\

The here-document fragments can be used to supply data to \c{stdin} or to
compare output to the expected result for \c{stdout} and \c{stderr}. Note that
the order of here-document fragments must match the order of redirects, for
example:

\
: select-no-table-error
$* --interactive >>EOO <<EOI 2>>EOE
enter query:
EOO
SELECT * FROM no_such_table
EOI
error: no such table 'no_such_table'
EOE
\

The lines in here-document are expanded as if they were double-quoted except
that the double quote itself is not treated as special. This means we can use
variables and evaluation contexts in here-documents but have to escape the
\c{\\$(} character set.

If the preceding command line starts with leading whitespaces, then the
equivalent number is stripped (if present) from each here-document line
(including the end marker). For example, the following two testscript
fragments are equivalent:

\
{
  $* <<EOI
  foo
  bar
  EOI
}
\

\
{
  $* <<EOI
foo
bar
EOI
}
\

The leading whitespace stripping does not apply to line continuations.

\h1#style|Style Guide|

This section describes the Testscript style that is used in the \c{build2}
projects. The primary goal of testing in \c{build2} is not to exhaustively
test every possible situation. Rather, it is to keep tests comprehensible
and maintainable in the long run.

To this effect, don't try to test every possible combination; this striving
will quickly lead to everyone drowning in hundreds of tests that are only
slight variations of each other. Sometimes combination tests are useful but
generally keep things simple and test one thing at a time. The believe here is
that real-world usage will uncover much more interesting interactions that you
would never have thought of yourself.To quote a famous physicist, \"\i{... the
imagination of nature is far, far greater than the imagination of man.}\"

To expand on combination tests, don't confuse them with corner case tests. As
an example, say you have tests for feature A and B. Now you wonder what if for
some reason they don't work together. Note that you don't have a clear
understanding of why they might not work together; you just want to add one
more test, \i{for good measure}. We don't do that. To put it another way, for
each test you should have a clear understanding of what logic in the code you
are testing.

One approach that we found works well is to look at the changes you would like
to commit and make sure you have a test that exercises each \i{logic
branch}. It is also a good idea to keep testing in mind as you implement
things. When tempted to add a small special case just to make the result
\i{nicer}, remember that you will also have to test this special case. Given a
choice, always prefer functional to unit tests since the former test the end
result rather than something intermediate and possibly mocked.

Documentation-wise, each test should at least include explicit id that
adequately summarizes what it tests. Add summary or even details for more
complex tests. Failure tests almost always fall into this category.

Use the leading description for multi-line tests, for example:

\
: multi-name
:
$* John Jane >>EOO
Hello, John!
Hello, Jane!
EOO
\

Here is an example of a description that includes all three components:

\
: multi-name
: Test multiple name arguments
:
: This test makes sure we properly handle multiple names passed as
: separate command line arguments.
:
$* John Jane >>EOO
Hello, John!
Hello, Jane!
EOO
\

Separate multi-line tests with blank lines. You may want to place larger tests
into explicit test scopes for better visual separation (this is especially
helpful if the test contains blank lines, for example, in here-document
fragments). In this case the description should come before the scope. Note
that here-documents are indented as well. For example:

\
: multi-name
:
{
  $* John Jane >>EOO
  Hello, John!

  Hello, Jane!

  EOO
}
\

One-line tests may use the trailing description (which must always be
the test id). Within a test block (one-liners without a blank between
them), the ids should be aligned, for example:

\
$* John >\"Hi, John!\"       : custom-john
$* World >\"Hello, World!\"  : custom-world
\

Note that you are free to put multiple spaces between the end of the command
line and the trailing description. But don't try to align ids between blocks
\- this is a maintenance pain.

If multiple tests belong to the same group, consider placing them into an
explicit group scope. A good indication that tests form a group is if their
ids start with the same prefix, as in the above example. If placing tests into
a group scope, use the prefix as the group's id and don't repeat it in the
tests. It is also a good idea to give the summary of the group, for example:

\
: custom
: Test custom greetings
:
{
  $* John >\"Hi, John!\"       : john
  $* World >\"Hello, World!\"  : world
}
\

In the same vein, don't repeat the testscript id in group or test ids. For
example, if the above tests were in the \c{greeting.test} testscript, then
using \c{custom-greeting} as the group id would be unnecessarily repetitive
since the id path would become, for example,
\c{greeting/custom-greeting/john}.

"
