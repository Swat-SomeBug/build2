// file      : build2/module -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD2_MODULE
#define BUILD2_MODULE

#include <map>

#include <build2/types>
#include <build2/utility>

#include <build2/diagnostics>

namespace build2
{
  class scope;
  class location;

  class module
  {
  public:
    virtual
    ~module () = default;
  };

  extern "C"
  using module_boot_function =
    void (scope& root, const location&, unique_ptr<module>&);

  // Return false if the module configuration (normally based on the default
  // values) was unsuccessful but this is not (yet) an error. One example
  // would be the optional use of a module. Or a module might remain
  // unconfigured for as long as it is actually not used (e.g., install,
  // dist). The return value is used to set the <module>.configured variable.
  //
  extern "C"
  using module_init_function =
    bool (scope& root,
          scope& base,
          const location&,
          unique_ptr<module>&,
          bool first,     // First time for this project.
          bool optional); // Loaded with 'using?' (optional module).


  struct module_state
  {
    bool boot; // True if the module boot'ed but not yet init'ed.
    module_init_function* init;
    unique_ptr<build2::module> module;
    const location loc; // Boot location.
  };

  using loaded_module_map = std::map<string, module_state>;

  // Load and boot the specified module.
  //
  void
  boot_module (const string& name, scope& root, const location&);

  // Load (if not already loaded) and initialize the specified module. Used
  // by the parser but also by some modules to load prerequisite modules.
  // Return true if the module was both successfully loaded and configured
  // (false can only be returned if optional).
  //
  bool
  load_module (bool optional,
               const std::string& name,
               scope& root,
               scope& base,
               const location&);

  // Builtin modules.
  //
  struct module_functions
  {
    module_boot_function* boot;
    module_init_function* init;
  };

  using available_module_map = std::map<string, module_functions>;
  extern available_module_map builtin_modules;
}

#endif // BUILD2_MODULE
