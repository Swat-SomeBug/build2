// file      : build2/utility -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD2_UTILITY
#define BUILD2_UTILITY

#include <utility>       // move(), make_pair()
#include <cassert>       // assert()
#include <exception>     // uncaught_exception()
#include <unordered_set>

#include <build2/types>

namespace build2
{
  using std::move;
  using std::make_pair;

  // Empty string and path.
  //
  extern const std::string empty_string;
  extern const path empty_path;
  extern const dir_path empty_dir_path;

  // Parse version string in the X.Y.Z[-{a|b}N] to a version integer in the
  // AABBCCDD form as describe in <build2/version>. Throw invalid_argument
  // if the passed string is not a valid version.
  //
  unsigned int
  to_version (const string&);

  // Call a function if there is an exception.
  //

  // Means we are in the body of a destructor that is being called
  // as part of the exception stack unwindining. Used to compensate
  // for the deficiencies of uncaught_exception() until C++17
  // uncaught_exceptions() becomes available.
  //
  // @@ MT: will have to be TLS.
  //
  extern bool exception_unwinding_dtor;

  template <typename F>
  struct exception_guard;

  template <typename F>
  inline exception_guard<F>
  make_exception_guard (F f)
  {
    return exception_guard<F> (move (f));
  }

  template <typename F>
  struct exception_guard
  {
    exception_guard (F f): f_ (move (f)) {}
    ~exception_guard ()
    {
      if (std::uncaught_exception ())
      {
        exception_unwinding_dtor = true;
        f_ ();
        exception_unwinding_dtor = false;
      }
    }

  private:
    F f_;
  };

  // Pools (@@ perhaps move into a separate header).
  //
  struct string_pool: std::unordered_set<std::string>
  {
    const std::string&
    find (const char* s) {return *emplace (s).first;}

    const std::string&
    find (const std::string& s) {return *emplace (s).first;}
  };
}

#endif // BUILD2_UTILITY
