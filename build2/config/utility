// file      : build2/config/utility -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD2_CONFIG_UTILITY
#define BUILD2_CONFIG_UTILITY

#include <string>
#include <utility>    // pair
#include <functional> // reference_wrapper

#include <build2/types>
#include <build2/variable>
#include <build2/diagnostics>

namespace build2
{
  class scope;

  namespace config
  {
    // Set, if necessary, a required config.* variable.
    //
    // If override is true and the variable doesn't come from this root
    // scope or from the command line, then its value is "overridden"
    // for this root scope.
    //
    // Return the reference to the value as well as the indication of
    // whether the variable has actually been set.
    //
    template <typename T>
    std::pair<std::reference_wrapper<const value>, bool>
    required (scope& root,
              const variable&,
              const T& default_value,
              bool override = false);

    template <typename T>
    inline std::pair<std::reference_wrapper<const value>, bool>
    required (scope& root,
              const std::string& name,
              const T& default_value,
              bool override = false)
    {
      return required (root, var_pool.find (name), default_value, override);
    }

    inline std::pair<std::reference_wrapper<const value>, bool>
    required (scope& root,
              const std::string& name,
              const char* default_value,
              bool override = false)
    {
      return required (root, name, std::string (default_value), override);
    }

    // Set, if necessary, an optional config.* variable. In particular,
    // an unspecified variable is set to NULL which is used to distinguish
    // between the "configured as unspecified" and "not yet configured"
    // cases.
    //
    // Return the value, which can be NULL.
    //
    const value&
    optional (scope& root, const variable&);

    inline const value&
    optional (scope& root, const std::string& var)
    {
      return optional (root, var_pool.find (var));
    }

    // As above but assumes the value is dir_path and makes it
    // absolute if the value specified on the command line is
    // relative.
    //
    const value&
    optional_absolute (scope& root, const variable&);

    inline const value&
    optional_absolute (scope& root, const std::string& var)
    {
      return optional_absolute (root, var_pool.find (var));
    }

    // Check whether there are any variables specified from the config
    // namespace. The idea is that we can check if there are any, say,
    // config.install.* values. If there are none, then we can assume
    // this functionality is not (yet) used and omit writing a whole
    // bunch of NULL config.install.* values to the config.build file.
    // We call it omitted/delayed configuration.
    //
    // Note that this function detects and ignores the special
    // config.*.configured variable which may be used by a module to
    // "remember" that it is unconfigured.
    //
    bool
    specified (scope& root, const std::string& ns);

    // @@ Why are these here?
    //

    // Add all the values from a variable to the C-string list. T is
    // either target or scope. The variable is expected to be of type
    // strings.
    //
    template <typename T>
    void
    append_options (cstrings& args, T& s, const char* var);

    // As above but from the strings value directly.
    //
    void
    append_options (cstrings& args, const const_strings_value&);

    // Check if a specified option is present in the variable value.
    // T is either target or scope.
    //
    template <typename T>
    bool
    find_option (const char* option, T& s, const char* var);
  }
}

#include <build2/config/utility.txx>
#include <build2/config/utility.ixx>

#endif // BUILD2_CONFIG_UTILITY
