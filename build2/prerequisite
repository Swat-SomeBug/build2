// file      : build2/prerequisite -*- C++ -*-
// copyright : Copyright (c) 2014-2017 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD2_PREREQUISITE
#define BUILD2_PREREQUISITE

#include <unordered_set>

#include <build2/types>
#include <build2/utility>

#include <build2/target-key>
#include <build2/diagnostics>

namespace build2
{
  class scope;
  class target;

  // Light-weight (by being shallow-pointing) prerequisite key, similar
  // to (and based on) target key.
  //
  // Note that unlike prerequisite, the key is not (necessarily) owned by a
  // target. So for the key we instead have the base scope of the target that
  // (would) own it. Note that we assume keys to be ephemeral enough for the
  // base scope to remain unchanged.
  //
  class prerequisite_key
  {
  public:
    typedef build2::scope scope_type;

    const optional<string>& proj;
    target_key tk;                // The .dir and .out members can be relative.
    scope_type* scope;            // Can be NULL if tk.dir is absolute.

    static const optional<string> nullproj;

    template <typename T>
    bool is_a () const {return tk.is_a<T> ();}
    bool is_a (const target_type& tt) const {return tk.is_a (tt);}
  };

  ostream&
  operator<< (ostream&, const prerequisite_key&);

  class prerequisite
  {
  public:
    typedef build2::target target_type;
    typedef build2::target_type target_type_type;

    // Note that unlike targets, for prerequisites an empty out directory
    // means undetermined rather than being definitely in the out tree.
    //
    const optional<string>  proj;
    const target_type_type& type;
    const dir_path dir;         // Normalized absolute or relative (to scope).
    const dir_path out;         // Empty, normalized absolute, or relative.
    const string name;
    const optional<string> ext; // Absent if unspecified.

    target_type& owner;         // Target to which this prerequisite belongs.

    target_type* target;        // NULL if not yet resolved. Note that this
                                // should always be the "primary target", not
                                // a member of a target group.

  public:
    prerequisite (optional<string> p,
                  const target_type_type& t,
                  dir_path d,
                  dir_path o,
                  string n,
                  optional<string> e,
                  target_type& w)
        : proj (move (p)),
          type (t),
          dir (move (d)),
          out (move (o)),
          name (move (n)),
          ext (move (e)),
          owner (w),
          target (nullptr) {}

    // Make a copy for a new owner target. Note that both owner targets should
    // be in the same scope.
    //
    prerequisite (const prerequisite&, target_type& owner);

    // Make a prerequisite from a target.
    //
    prerequisite (target_type&, target_type& owner);

    prerequisite (const prerequisite&) = delete;
    prerequisite (prerequisite&&) = default;

    prerequisite& operator= (const prerequisite&) = delete;
    prerequisite& operator= (prerequisite&&) = default;

    // Note that the returned key "tracks" the prerequisite; that is, any
    // updates to the prerequisite's members will be reflected in the key.
    //
    prerequisite_key
    key () const;

    // Prerequisite (target) type.
    //
  public:
    template <typename T>
    bool
    is_a () const {return type.is_a<T> ();}

    bool
    is_a (const target_type_type& tt) const {return type.is_a (tt);}
  };

  inline ostream&
  operator<< (ostream& os, const prerequisite& p)
  {
    return os << p.key ();
  }
}

#endif // BUILD2_PREREQUISITE
