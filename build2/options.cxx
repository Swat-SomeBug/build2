// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

// Begin prologue.
//
//
// End prologue.

#include <build2/options>

#include <map>
#include <set>
#include <string>
#include <vector>
#include <ostream>
#include <sstream>

namespace cl
{
  // unknown_option
  //
  unknown_option::
  ~unknown_option () throw ()
  {
  }

  void unknown_option::
  print (::std::ostream& os) const
  {
    os << "unknown option '" << option ().c_str () << "'";
  }

  const char* unknown_option::
  what () const throw ()
  {
    return "unknown option";
  }

  // unknown_argument
  //
  unknown_argument::
  ~unknown_argument () throw ()
  {
  }

  void unknown_argument::
  print (::std::ostream& os) const
  {
    os << "unknown argument '" << argument ().c_str () << "'";
  }

  const char* unknown_argument::
  what () const throw ()
  {
    return "unknown argument";
  }

  // missing_value
  //
  missing_value::
  ~missing_value () throw ()
  {
  }

  void missing_value::
  print (::std::ostream& os) const
  {
    os << "missing value for option '" << option ().c_str () << "'";
  }

  const char* missing_value::
  what () const throw ()
  {
    return "missing option value";
  }

  // invalid_value
  //
  invalid_value::
  ~invalid_value () throw ()
  {
  }

  void invalid_value::
  print (::std::ostream& os) const
  {
    os << "invalid value '" << value ().c_str () << "' for option '"
       << option ().c_str () << "'";
  }

  const char* invalid_value::
  what () const throw ()
  {
    return "invalid option value";
  }

  // eos_reached
  //
  void eos_reached::
  print (::std::ostream& os) const
  {
    os << what ();
  }

  const char* eos_reached::
  what () const throw ()
  {
    return "end of argument stream reached";
  }

  // scanner
  //
  scanner::
  ~scanner ()
  {
  }

  // argv_scanner
  //
  bool argv_scanner::
  more ()
  {
    return i_ < argc_;
  }

  const char* argv_scanner::
  peek ()
  {
    if (i_ < argc_)
      return argv_[i_];
    else
      throw eos_reached ();
  }

  const char* argv_scanner::
  next ()
  {
    if (i_ < argc_)
    {
      const char* r (argv_[i_]);

      if (erase_)
      {
        for (int i (i_ + 1); i < argc_; ++i)
          argv_[i - 1] = argv_[i];

        --argc_;
        argv_[argc_] = 0;
      }
      else
        ++i_;

      return r;
    }
    else
      throw eos_reached ();
  }

  void argv_scanner::
  skip ()
  {
    if (i_ < argc_)
      ++i_;
    else
      throw eos_reached ();
  }

  template <typename X>
  struct parser
  {
    static void
    parse (X& x, bool& xs, scanner& s)
    {
      std::string o (s.next ());

      if (s.more ())
      {
        std::string v (s.next ());
        std::istringstream is (v);
        if (!(is >> x && is.eof ()))
          throw invalid_value (o, v);
      }
      else
        throw missing_value (o);

      xs = true;
    }
  };

  template <>
  struct parser<bool>
  {
    static void
    parse (bool& x, scanner& s)
    {
      s.next ();
      x = true;
    }
  };

  template <>
  struct parser<std::string>
  {
    static void
    parse (std::string& x, bool& xs, scanner& s)
    {
      const char* o (s.next ());

      if (s.more ())
        x = s.next ();
      else
        throw missing_value (o);

      xs = true;
    }
  };

  template <typename X>
  struct parser<std::vector<X> >
  {
    static void
    parse (std::vector<X>& c, bool& xs, scanner& s)
    {
      X x;
      bool dummy;
      parser<X>::parse (x, dummy, s);
      c.push_back (x);
      xs = true;
    }
  };

  template <typename X>
  struct parser<std::set<X> >
  {
    static void
    parse (std::set<X>& c, bool& xs, scanner& s)
    {
      X x;
      bool dummy;
      parser<X>::parse (x, dummy, s);
      c.insert (x);
      xs = true;
    }
  };

  template <typename K, typename V>
  struct parser<std::map<K, V> >
  {
    static void
    parse (std::map<K, V>& m, bool& xs, scanner& s)
    {
      const char* o (s.next ());

      if (s.more ())
      {
        std::string ov (s.next ());
        std::string::size_type p = ov.find ('=');

        K k = K ();
        V v = V ();
        std::string kstr (ov, 0, p);
        std::string vstr (ov, (p != std::string::npos ? p + 1 : ov.size ()));

        int ac (2);
        char* av[] = 
        {
          const_cast<char*> (o), 0
        };

        bool dummy;
        if (!kstr.empty ())
        {
          av[1] = const_cast<char*> (kstr.c_str ());
          argv_scanner s (0, ac, av);
          parser<K>::parse (k, dummy, s);
        }

        if (!vstr.empty ())
        {
          av[1] = const_cast<char*> (vstr.c_str ());
          argv_scanner s (0, ac, av);
          parser<V>::parse (v, dummy, s);
        }

        m[k] = v;
      }
      else
        throw missing_value (o);

      xs = true;
    }
  };

  template <typename X, typename T, T X::*M>
  void
  thunk (X& x, scanner& s)
  {
    parser<T>::parse (x.*M, s);
  }

  template <typename X, typename T, T X::*M, bool X::*S>
  void
  thunk (X& x, scanner& s)
  {
    parser<T>::parse (x.*M, x.*S, s);
  }
}

#include <map>
#include <cstring>

// options
//

options::
options ()
: help_ (),
  version_ (),
  v_ (),
  q_ (),
  verbose_ (1),
  verbose_specified_ (false)
{
}

options::
options (int& argc,
         char** argv,
         bool erase,
         ::cl::unknown_mode opt,
         ::cl::unknown_mode arg)
: help_ (),
  version_ (),
  v_ (),
  q_ (),
  verbose_ (1),
  verbose_specified_ (false)
{
  ::cl::argv_scanner s (argc, argv, erase);
  _parse (s, opt, arg);
}

options::
options (int start,
         int& argc,
         char** argv,
         bool erase,
         ::cl::unknown_mode opt,
         ::cl::unknown_mode arg)
: help_ (),
  version_ (),
  v_ (),
  q_ (),
  verbose_ (1),
  verbose_specified_ (false)
{
  ::cl::argv_scanner s (start, argc, argv, erase);
  _parse (s, opt, arg);
}

options::
options (int& argc,
         char** argv,
         int& end,
         bool erase,
         ::cl::unknown_mode opt,
         ::cl::unknown_mode arg)
: help_ (),
  version_ (),
  v_ (),
  q_ (),
  verbose_ (1),
  verbose_specified_ (false)
{
  ::cl::argv_scanner s (argc, argv, erase);
  _parse (s, opt, arg);
  end = s.end ();
}

options::
options (int start,
         int& argc,
         char** argv,
         int& end,
         bool erase,
         ::cl::unknown_mode opt,
         ::cl::unknown_mode arg)
: help_ (),
  version_ (),
  v_ (),
  q_ (),
  verbose_ (1),
  verbose_specified_ (false)
{
  ::cl::argv_scanner s (start, argc, argv, erase);
  _parse (s, opt, arg);
  end = s.end ();
}

options::
options (::cl::scanner& s,
         ::cl::unknown_mode opt,
         ::cl::unknown_mode arg)
: help_ (),
  version_ (),
  v_ (),
  q_ (),
  verbose_ (1),
  verbose_specified_ (false)
{
  _parse (s, opt, arg);
}

::cl::usage_para options::
print_usage (::std::ostream& os, ::cl::usage_para p)
{
  CLI_POTENTIALLY_UNUSED (os);

  if (p == ::cl::usage_para::text)
    os << ::std::endl;

  os << "--help            Print usage information and exit." << ::std::endl;

  os << "--version         Print version and exit." << ::std::endl;

  os << "-v                Print actual commands being executed." << ::std::endl;

  os << "-q                Run quietly, only printing error messages." << ::std::endl;

  os << "--verbose <level> Set the diagnostics verbosity to <level> between 0 (disabled)" << ::std::endl
     << "                  and 6 (lots of information)." << ::std::endl;

  p = ::cl::usage_para::option;

  return p;
}

typedef
std::map<std::string, void (*) (options&, ::cl::scanner&)>
_cli_options_map;

static _cli_options_map _cli_options_map_;

struct _cli_options_map_init
{
  _cli_options_map_init ()
  {
    _cli_options_map_["--help"] = 
    &::cl::thunk< options, bool, &options::help_ >;
    _cli_options_map_["--version"] = 
    &::cl::thunk< options, bool, &options::version_ >;
    _cli_options_map_["-v"] = 
    &::cl::thunk< options, bool, &options::v_ >;
    _cli_options_map_["-q"] = 
    &::cl::thunk< options, bool, &options::q_ >;
    _cli_options_map_["--verbose"] = 
    &::cl::thunk< options, std::uint16_t, &options::verbose_,
      &options::verbose_specified_ >;
  }
};

static _cli_options_map_init _cli_options_map_init_;

bool options::
_parse (const char* o, ::cl::scanner& s)
{
  _cli_options_map::const_iterator i (_cli_options_map_.find (o));

  if (i != _cli_options_map_.end ())
  {
    (*(i->second)) (*this, s);
    return true;
  }

  return false;
}

void options::
_parse (::cl::scanner& s,
        ::cl::unknown_mode opt_mode,
        ::cl::unknown_mode arg_mode)
{
  bool opt = true;

  while (s.more ())
  {
    const char* o = s.peek ();

    if (std::strcmp (o, "--") == 0)
    {
      s.skip ();
      opt = false;
      continue;
    }

    if (opt && _parse (o, s));
    else if (opt && std::strncmp (o, "-", 1) == 0 && o[1] != '\0')
    {
      switch (opt_mode)
      {
        case ::cl::unknown_mode::skip:
        {
          s.skip ();
          continue;
        }
        case ::cl::unknown_mode::stop:
        {
          break;
        }
        case ::cl::unknown_mode::fail:
        {
          throw ::cl::unknown_option (o);
        }
      }

      break;
    }
    else
    {
      switch (arg_mode)
      {
        case ::cl::unknown_mode::skip:
        {
          s.skip ();
          continue;
        }
        case ::cl::unknown_mode::stop:
        {
          break;
        }
        case ::cl::unknown_mode::fail:
        {
          throw ::cl::unknown_argument (o);
        }
      }

      break;
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

