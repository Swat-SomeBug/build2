// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

#ifndef BUILD2_B_OPTIONS
#define BUILD2_B_OPTIONS

// Begin prologue.
//
//
// End prologue.

#include <deque>
#include <iosfwd>
#include <string>
#include <cstddef>
#include <exception>

#ifndef CLI_POTENTIALLY_UNUSED
#  if defined(_MSC_VER) || defined(__xlC__)
#    define CLI_POTENTIALLY_UNUSED(x) (void*)&x
#  else
#    define CLI_POTENTIALLY_UNUSED(x) (void)x
#  endif
#endif

namespace build2
{
  namespace cl
  {
    class usage_para
    {
      public:
      enum value
      {
        none,
        text,
        option
      };

      usage_para (value);

      operator value () const 
      {
        return v_;
      }

      private:
      value v_;
    };

    class unknown_mode
    {
      public:
      enum value
      {
        skip,
        stop,
        fail
      };

      unknown_mode (value);

      operator value () const 
      {
        return v_;
      }

      private:
      value v_;
    };

    // Exceptions.
    //

    class exception: public std::exception
    {
      public:
      virtual void
      print (::std::ostream&) const = 0;
    };

    ::std::ostream&
    operator<< (::std::ostream&, const exception&);

    class unknown_option: public exception
    {
      public:
      virtual
      ~unknown_option () throw ();

      unknown_option (const std::string& option);

      const std::string&
      option () const;

      virtual void
      print (::std::ostream&) const;

      virtual const char*
      what () const throw ();

      private:
      std::string option_;
    };

    class unknown_argument: public exception
    {
      public:
      virtual
      ~unknown_argument () throw ();

      unknown_argument (const std::string& argument);

      const std::string&
      argument () const;

      virtual void
      print (::std::ostream&) const;

      virtual const char*
      what () const throw ();

      private:
      std::string argument_;
    };

    class missing_value: public exception
    {
      public:
      virtual
      ~missing_value () throw ();

      missing_value (const std::string& option);

      const std::string&
      option () const;

      virtual void
      print (::std::ostream&) const;

      virtual const char*
      what () const throw ();

      private:
      std::string option_;
    };

    class invalid_value: public exception
    {
      public:
      virtual
      ~invalid_value () throw ();

      invalid_value (const std::string& option,
                     const std::string& value);

      const std::string&
      option () const;

      const std::string&
      value () const;

      virtual void
      print (::std::ostream&) const;

      virtual const char*
      what () const throw ();

      private:
      std::string option_;
      std::string value_;
    };

    class eos_reached: public exception
    {
      public:
      virtual void
      print (::std::ostream&) const;

      virtual const char*
      what () const throw ();
    };

    class file_io_failure: public exception
    {
      public:
      virtual
      ~file_io_failure () throw ();

      file_io_failure (const std::string& file);

      const std::string&
      file () const;

      virtual void
      print (::std::ostream&) const;

      virtual const char*
      what () const throw ();

      private:
      std::string file_;
    };

    class unmatched_quote: public exception
    {
      public:
      virtual
      ~unmatched_quote () throw ();

      unmatched_quote (const std::string& argument);

      const std::string&
      argument () const;

      virtual void
      print (::std::ostream&) const;

      virtual const char*
      what () const throw ();

      private:
      std::string argument_;
    };

    class scanner
    {
      public:
      virtual
      ~scanner ();

      virtual bool
      more () = 0;

      virtual const char*
      peek () = 0;

      virtual const char*
      next () = 0;

      virtual void
      skip () = 0;
    };

    class argv_scanner: public scanner
    {
      public:
      argv_scanner (int& argc, char** argv, bool erase = false);
      argv_scanner (int start, int& argc, char** argv, bool erase = false);

      int
      end () const;

      virtual bool
      more ();

      virtual const char*
      peek ();

      virtual const char*
      next ();

      virtual void
      skip ();

      private:
      int i_;
      int& argc_;
      char** argv_;
      bool erase_;
    };

    class argv_file_scanner: public argv_scanner
    {
      public:
      argv_file_scanner (int& argc,
                         char** argv,
                         const std::string& option,
                         bool erase = false);

      argv_file_scanner (int start,
                         int& argc,
                         char** argv,
                         const std::string& option,
                         bool erase = false);

      struct option_info
      {
        // If search_func is not NULL, it is called, with the arg
        // value as the second argument, to locate the options file.
        // If it returns an empty string, then the file is ignored.
        //
        const char* option;
        std::string (*search_func) (const char*, void* arg);
        void* arg;
      };

      argv_file_scanner (int& argc,
                          char** argv,
                          const option_info* options,
                          std::size_t options_count,
                          bool erase = false);

      argv_file_scanner (int start,
                         int& argc,
                         char** argv,
                         const option_info* options,
                         std::size_t options_count,
                         bool erase = false);

      virtual bool
      more ();

      virtual const char*
      peek ();

      virtual const char*
      next ();

      virtual void
      skip ();

      private:
      const option_info*
      find (const char*) const;

      void
      load (const std::string& file);

      typedef argv_scanner base;

      const std::string option_;
      option_info option_info_;
      const option_info* options_;
      std::size_t options_count_;

      std::string hold_;
      std::deque<std::string> args_;
      bool skip_;
    };

    template <typename X>
    struct parser;
  }
}

#include <build2/types>

namespace build2
{
  class options
  {
    public:
    options ();

    void
    parse (int& argc,
           char** argv,
           bool erase = false,
           ::build2::cl::unknown_mode option = ::build2::cl::unknown_mode::fail,
           ::build2::cl::unknown_mode argument = ::build2::cl::unknown_mode::stop);

    void
    parse (int start,
           int& argc,
           char** argv,
           bool erase = false,
           ::build2::cl::unknown_mode option = ::build2::cl::unknown_mode::fail,
           ::build2::cl::unknown_mode argument = ::build2::cl::unknown_mode::stop);

    void
    parse (int& argc,
           char** argv,
           int& end,
           bool erase = false,
           ::build2::cl::unknown_mode option = ::build2::cl::unknown_mode::fail,
           ::build2::cl::unknown_mode argument = ::build2::cl::unknown_mode::stop);

    void
    parse (int start,
           int& argc,
           char** argv,
           int& end,
           bool erase = false,
           ::build2::cl::unknown_mode option = ::build2::cl::unknown_mode::fail,
           ::build2::cl::unknown_mode argument = ::build2::cl::unknown_mode::stop);

    void
    parse (::build2::cl::scanner&,
           ::build2::cl::unknown_mode option = ::build2::cl::unknown_mode::fail,
           ::build2::cl::unknown_mode argument = ::build2::cl::unknown_mode::stop);

    // Option accessors.
    //
    const bool&
    v () const;

    const bool&
    q () const;

    const uint16_t&
    verbose () const;

    bool
    verbose_specified () const;

    const path&
    buildfile () const;

    bool
    buildfile_specified () const;

    const path&
    config_guess () const;

    bool
    config_guess_specified () const;

    const path&
    config_sub () const;

    bool
    config_sub_specified () const;

    const string&
    pager () const;

    bool
    pager_specified () const;

    const strings&
    pager_option () const;

    bool
    pager_option_specified () const;

    const bool&
    help () const;

    const bool&
    version () const;

    // Print usage information.
    //
    static ::build2::cl::usage_para
    print_usage (::std::ostream&,
                 ::build2::cl::usage_para = ::build2::cl::usage_para::none);

    // Implementation details.
    //
    protected:
    bool
    _parse (const char*, ::build2::cl::scanner&);

    private:
    void
    _parse (::build2::cl::scanner&,
            ::build2::cl::unknown_mode option,
            ::build2::cl::unknown_mode argument);

    public:
    bool v_;
    bool q_;
    uint16_t verbose_;
    bool verbose_specified_;
    path buildfile_;
    bool buildfile_specified_;
    path config_guess_;
    bool config_guess_specified_;
    path config_sub_;
    bool config_sub_specified_;
    string pager_;
    bool pager_specified_;
    strings pager_option_;
    bool pager_option_specified_;
    bool help_;
    bool version_;
  };
}

// Print page usage information.
//
namespace build2
{
  ::build2::cl::usage_para
  print_b_usage (::std::ostream&,
                 ::build2::cl::usage_para = ::build2::cl::usage_para::none);
}

#include <build2/b-options.ixx>

// Begin epilogue.
//
//
// End epilogue.

#endif // BUILD2_B_OPTIONS
