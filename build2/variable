// file      : build2/variable -*- C++ -*-
// copyright : Copyright (c) 2014-2016 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BUILD2_VARIABLE
#define BUILD2_VARIABLE

#include <map>
#include <functional>    // hash
#include <type_traits>   // aligned_storage
#include <unordered_set>

#include <butl/prefix-map>

#include <build2/types>
#include <build2/utility>

#include <build2/target-type>

namespace build2
{
  class value;
  struct variable;
  struct lookup;

  struct value_type
  {
    const char* name;  // Type name for diagnostics.
    const size_t size; // Type size in value::data_ (only used for PODs).

    // Base type, if any. We have very limited support for inheritance: a
    // const value (but not non-const) can be cast to the base type. In
    // particular, a derived/base value cannot be assigned to base/derived.
    // If not NULL, then the cast function below is expected to return the
    // base pointer if its second argument points to the base's value_type.
    //
    const value_type* base;

    // Destroy the value. If it is NULL, then the type is assumed to be POD
    // with a trivial destructor.
    //
    void (*const dtor) (value&);

    // Copy/move constructor and copy/move assignment for data_. If NULL, then
    // assume the stored data is POD. If move is true then the second argument
    // can be const_cast and moved from. copy_assign() is only called with
    // non-NULL first argument.
    //
    void (*const copy_ctor) (value&, const value&, bool move);
    void (*const copy_assign) (value&, const value&, bool move);

    // While assign cannot be NULL, if append or prepend is NULL, then this
    // means this type doesn't support this operation. Variable is optional
    // and is provided only for diagnostics. Return true if the resulting
    // value is not empty.
    //
    void (*const assign) (value&, names&&, const variable*);
    void (*const append) (value&, names&&, const variable*);
    void (*const prepend) (value&, names&&, const variable*);

    // Reverse the value back to a vector of names. Storage can be used by the
    // implementation if necessary. Cannot be NULL.
    //
    names_view (*const reverse) (const value&, names& storage);

    // Cast value::data_ storage to value type so that the result can be
    // static_cast to const T*. If it is NULL, then cast data_ directly. Note
    // that this function is used for both const and non-const values.
    //
    const void* (*const cast) (const value&, const value_type*);

    // If NULL, then the types are compared as PODs using memcmp().
    //
    int (*const compare) (const value&, const value&);

    // If NULL, then the value is never empty.
    //
    bool (*const empty) (const value&);
  };

  enum class variable_visibility
  {
    scope,    // This scope (no outer scopes).
    project,  // This project (no outer projects).
    normal    // All outer scopes.
  };

  // variable
  //
  // The two variables are considered the same if they have the same name.
  //
  // If the variable is overridden on the command line, then override is the
  // chain of the special override variables. Their names are derived from the
  // main variable name as <name>.{__override,__prefix,__suffix} and they are
  // not entered into the var_pool. The override variables only vary in their
  // names and visibility.
  //
  // Note also that we don't propagate the variable type to override variables
  // and we keep override values as untyped names. They get "typed" when they
  // are applied.
  //
  // We use the "modify original, override on query" model. Because of that, a
  // modified value does not necessarily represent the actual value so care
  // must be taken to re-query after (direct) modification. And because of
  // that, variables set by the C++ code are by default non-overridable.
  //
  // Initial processing including entering of global overrides happens in
  // reset() before any other variables. Project wide overrides are entered in
  // main(). Overriding happens in scope::find_override().
  //
  struct variable
  {
    string name;
    mutable const value_type* type;        // If NULL, then not (yet) typed.
    mutable unique_ptr<variable> override;
    variable_visibility visibility;
  };

  inline bool
  operator== (const variable& x, const variable& y) {return x.name == y.name;}

  //
  //
  class value
  {
  public:
    const value_type* type; // NULL means this value is not (yet) typed.
    bool null;

    // Extra data that is associated with the value that can be used to store
    // flags, etc. It is initialized to 0 and copied (but not assigned) from
    // one value to another but is otherwise untouched (not even when the
    // value is reset to NULL).
    //
    // Note: if deciding to use for something make sure it is not overlapping
    // with an existing usage.
    //
    uint16_t extra;

    explicit operator bool () const {return !null;}
    bool operator== (nullptr_t) const {return null;}
    bool operator!= (nullptr_t) const {return !null;}

    // Check in a type-independent way if the value is empty. The value must
    // not be NULL.
    //
    bool
    empty () const;

    // Creation. A default-initialzied value is NULL and can be reset back to
    // NULL by assigning nullptr. Values can be copied and copy-assigned. Note
    // that for assignment, the values' types should be the same or LHS should
    // be untyped.
    //
    //
  public:
    ~value () {*this = nullptr;}

    explicit
    value (const value_type* t = nullptr): type (t), null (true), extra (0) {}

    explicit
    value (names&&); // Create untyped value.

    // Note: preserves type.
    //
    value&
    operator= (nullptr_t) {if (!null) reset (); return *this;}

    value (value&&);
    explicit value (const value&);
    value& operator= (value&&);
    value& operator= (const value&);
    value& operator= (reference_wrapper<value>);
    value& operator= (reference_wrapper<const value>);

    // Assign/Append/Prepend.
    //
  public:
    // Assign/append a typed value. For assign, LHS should be either of the
    // same type or untyped. For append, LHS should be either of the same type
    // or untyped and NULL.
    //
    template <typename T> value& operator= (T);
    template <typename T> value& operator+= (T);

    template <typename T> value& operator+= (T* v) {
      return v != nullptr ? *this += *v : *this;}

    value& operator= (const char* v) {return *this = string (v);}
    value& operator+= (const char* v) {return *this += string (v);}

    // Assign/append/prepend raw data. Variable is optional and is only used
    // for diagnostics.
    //
    void
    assign (names&&, const variable*);

    void
    append (names&&, const variable*);

    void
    prepend (names&&, const variable*);

    // Implementation details, don't use directly except in representation
    // type implementations.
    //
  public:
    // Fast, unchecked cast of data_ to T.
    //
    template<typename T> T& as () & {return reinterpret_cast<T&> (data_);}
    template<typename T> T&& as () && {return reinterpret_cast<T&&> (data_);}
    template<typename T> const T& as () const& {
      return reinterpret_cast<const T&> (data_);}

  public:
    // The maximum size we can store directly in the value is that of a name,
    // which is sufficient for the most commonly used types (string, vector,
    // map) on all the platforms that we support (each type should static
    // assert this in its value_traits specialization below). Types that don't
    // fit will have to be handled with an extra dynamic allocation.
    //
    std::aligned_storage<sizeof (name)>::type data_;

    // VC 19 needs decltype.
    //
    static const size_t size_ = sizeof (decltype (data_));

    // Make sure we have sufficient storage for untyped values.
    //
    static_assert (sizeof (names) <= size_, "insufficient space");

  private:
    void
    reset ();
  };

  // The values should be of the same type (or both be untyped) except NULL
  // values can also be untyped. NULL values compare equal and a NULL value
  // is always less than a non-NULL.
  //
  bool operator== (const value&, const value&);
  bool operator!= (const value&, const value&);
  bool operator<  (const value&, const value&);
  bool operator<= (const value&, const value&);
  bool operator>  (const value&, const value&);
  bool operator>= (const value&, const value&);

  // Value cast. The first three expect the value to be not NULL. The cast
  // from lookup expects the value to aslo be defined.
  //
  // Why are these non-members? The cast is easier on the eyes and is also
  // consistent with the cast operators. The other two are for symmetry.
  //
  //
  template <typename T> T& cast (value&);
  template <typename T> T&& cast (value&&);
  template <typename T> const T& cast (const value&);
  template <typename T> const T& cast (const lookup&);

  // As above but returns NULL if the value is NULL (or not defined, in
  // case of lookup).
  //
  template <typename T> T* cast_null (value&);
  template <typename T> const T* cast_null (const value&);
  template <typename T> const T* cast_null (const lookup&);

  // As above but returns false if the value is NULL (or not defined, in case
  // of lookup). Note that the template argument is only for documentation and
  // should be bool (or semantically compatible).
  //
  template <typename T> T cast_false (const value& v);
  template <typename T> T cast_false (const lookup& l);

  // Assign value type to the value. In the second version the variable is
  // optional and is only used for diagnostics.
  //
  template <typename T>
  void typify (value&, const variable&);
  void typify (value&, const value_type&, const variable*);

  // Reverse the value back to names. The value should not be NULL and storage
  // should be empty.
  //
  vector_view<const name>
  reverse (const value&, names& storage);

  vector_view<name>
  reverse (value&, names& storage);

  // lookup
  //
  // A variable can be undefined, NULL, or contain a (potentially empty)
  // value.
  //
  class variable_map;

  struct lookup
  {
    using value_type = build2::value;

    const value_type* value;  // NULL if undefined.
    const variable_map* vars;

    bool
    defined () const {return value != nullptr;}

    // Note: returns true if defined and not NULL.
    //
    explicit operator bool () const {return defined () && !value->null;}

    const value_type& operator*  () const {return *value;}
    const value_type* operator-> () const {return value;}

    // Return true if this value belongs to the specified scope or target.
    // Note that it can also be a target type/pattern-specific value (in
    // which case it won't belong to either).
    //
    template <typename T>
    bool
    belongs (const T& x) const {return vars == &x.vars;}

    lookup (): value (nullptr), vars (nullptr) {}

    template <typename T>
    lookup (const value_type& v, const T& x): lookup (&v, &x.vars) {}

    lookup (const value_type& v, const variable_map& vs)
        : value (&v), vars (&vs) {}

    lookup (const value_type* v, const variable_map* vs)
        : value (v), vars (v != nullptr ? vs : nullptr) {}
  };

  // Two lookups are equal if they point to the same variable.
  //
  inline bool
  operator== (const lookup& x, const lookup& y)
  {
    bool r (x.value == y.value);
    assert (!r || x.vars == y.vars);
    return r;
  }

  inline bool
  operator!= (const lookup& x, const lookup& y) {return !(x == y);}


  // Representation types.
  //
  // Potential optimizations:
  //
  // - Split value::operator=/+=() into const T and T&&, also overload
  //   value_traits functions that they call.
  //
  // - Specialization for vector<names> (if used and becomes critical).
  //
  //
  template <typename T>
  struct value_traits;
  // {
  //   static_assert (sizeof (T) <= value::size_, "insufficient space");
  //
  //   // Convert name to T. If rhs is not NULL, then it is the second half
  //   // of a pair. Only needs to be provided by simple types. Throw
  //   // invalid_argument (without a message) if the name is not a valid
  //   // representation of value (in which case the name should remain
  //   // unchanged for diagnostics).
  //   //
  //   static T convert (name&&, name* rhs);
  //
  //   // Assign/append/prepend T to value which is already of type T but can
  //   // be NULL.
  //   //
  //   static void assign (value&, T&&);
  //   static void append (value&, T&&);
  //   static void prepend (value&, T&&);
  //
  //   // Reverse a value back to name. Only needs to be provided by simple
  //   // types.
  //   //
  //   static name reverse (const T&);
  //
  //   // Compare two values. Only needs to be provided by simple types.
  //   //
  //   static int compare (const T&, const T&);
  //
  //   // Return true if the value is empty.
  //   //
  //   static bool empty (const T&);
  //
  //   // For simple types (those that can be used as elements of containers),
  //   // type_name must be constexpr in order to sidestep the static init
  //   // order issue (in fact, that's the only reason we have it both here
  //   // and in value_type.name -- value_type cannot be constexpr because
  //   // of pointers to function template instantiations).
  //   //
  //   static const char* const type_name;
  //   static const build2::value_type value_type;
  // };

  // Convert name to a simple value. Throw invalid_argument (without any
  // message) if the name is not a valid representation of value (in which
  // case the name remains unchanged for diagnostics). The second version is
  // called for a pair.
  //
  template <typename T> T convert (name&&);
  template <typename T> T convert (name&&, name&&);

  // Default implementations of the dtor/copy_ctor/copy_assing callbacks for
  // types that are stored directly in value::data_ and the provide all the
  // necessary functions (copy/move ctor and assignment operator).
  //
  template <typename T>
  static void
  default_dtor (value&);

  template <typename T>
  static void
  default_copy_ctor (value&, const value&, bool);

  template <typename T>
  static void
  default_copy_assign (value&, const value&, bool);

  // Default implementations of the empty callback that calls
  // value_traits<T>::empty().
  //
  template <typename T>
  static bool
  default_empty (const value&);

  // Default implementations of the assign/append/prepend callbacks for simple
  // types. They call value_traits<T>::convert() and then pass the result to
  // value_traits<T>::assign()/append()/prepend(). As a result, it may not be
  // the most efficient way to do it. If the empty template parameter is true,
  // then an empty names sequence is converted to a default-constructed T. And
  // if false, then an empty value is not allowed.
  //
  template <typename T, bool empty>
  static void
  simple_assign (value&, names&&, const variable*);

  template <typename T, bool empty>
  static void
  simple_append (value&, names&&, const variable*);

  template <typename T, bool empty>
  static void
  simple_prepend (value&, names&&, const variable*);

  // Default implementations of the reverse callback for simple types that
  // calls value_traits<T>::reverse() and adds the result to the vector. As a
  // result, it may not be the most efficient way to do it.
  //
  template <typename T>
  static names_view
  simple_reverse (const value&, names&);

  // Default implementations of the compare callback for simple types that
  // calls value_traits<T>::compare().
  //
  template <typename T>
  static int
  simple_compare (const value&, const value&);

  // bool
  //
  template <>
  struct value_traits<bool>
  {
    static_assert (sizeof (bool) <= value::size_, "insufficient space");

    static bool convert (name&&, name*);
    static void assign (value&, bool);
    static void append (value&, bool); // OR.
    static name reverse (bool x) {return name (x ? "true" : "false", false);}
    static int compare (bool, bool);
    static bool empty (bool) {return false;}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  template <>
  struct value_traits<uint64_t>
  {
    static_assert (sizeof (uint64_t) <= value::size_, "insufficient space");

    static uint64_t convert (name&&, name*);
    static void assign (value&, uint64_t);
    static void append (value&, uint64_t); // ADD.
    static name reverse (uint64_t x) {return name (to_string (x), false);}
    static int compare (uint64_t, uint64_t);
    static bool empty (bool) {return false;}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  // string
  //
  template <>
  struct value_traits<string>
  {
    static_assert (sizeof (string) <= value::size_, "insufficient space");

    static string convert (name&&, name*);
    static void assign (value&, string&&);
    static void append (value&, string&&);
    static void prepend (value&, string&&);
    static name reverse (const string& x) {return name (x, false);}
    static int compare (const string&, const string&);
    static bool empty (const string& x) {return x.empty ();}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  // path
  //
  template <>
  struct value_traits<path>
  {
    static_assert (sizeof (path) <= value::size_, "insufficient space");

    static path convert (name&&, name*);
    static void assign (value&, path&&);
    static void append (value&, path&&);  // operator/
    static void prepend (value&, path&&); // operator/
    static name reverse (const path& x) {return name (x.string (), false);}
    static int compare (const path&, const path&);
    static bool empty (const path& x) {return x.empty ();}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  // dir_path
  //
  template <>
  struct value_traits<dir_path>
  {
    static_assert (sizeof (dir_path) <= value::size_, "insufficient space");

    static dir_path convert (name&&, name*);
    static void assign (value&, dir_path&&);
    static void append (value&, dir_path&&);  // operator/
    static void prepend (value&, dir_path&&); // operator/
    static name reverse (const dir_path& x) {return name (x, false);}
    static int compare (const dir_path&, const dir_path&);
    static bool empty (const dir_path& x) {return x.empty ();}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  // abs_dir_path
  //
  template <>
  struct value_traits<abs_dir_path>
  {
    static_assert (sizeof (abs_dir_path) <= value::size_,
                   "insufficient space");

    static abs_dir_path convert (name&&, name*);
    static void assign (value&, abs_dir_path&&);
    static void append (value&, abs_dir_path&&);  // operator/
    static name reverse (const abs_dir_path& x) {return name (x, false);}
    static int compare (const abs_dir_path&, const abs_dir_path&);
    static bool empty (const abs_dir_path& x) {return x.empty ();}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  // name
  //
  template <>
  struct value_traits<name>
  {
    static_assert (sizeof (name) <= value::size_, "insufficient space");

    static name convert (name&&, name*);
    static void assign (value&, name&&);
    static name reverse (const name& x) {return x;}
    static int compare (const name&, const name&);
    static bool empty (const name& x) {return x.empty ();}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  // process_path
  //
  // Note that instances that we store always have non-empty recall and
  // initial is its shallow copy.
  //
  template <>
  struct value_traits<process_path>
  {
    static_assert (sizeof (process_path) <= value::size_, "insufficient space");

    // This one is represented as a @-pair of names. As a result it cannot
    // be stored in a container.
    //
    static process_path convert (name&&, name*);
    static void assign (value&, process_path&&);
    static int compare (const process_path&, const process_path&);
    static bool empty (const process_path& x) {return x.empty ();}

    static const char* const type_name;
    static const build2::value_type value_type;
  };

  // vector<T>
  //
  template <typename T>
  struct value_traits<vector<T>>
  {
    static_assert (sizeof (vector<T>) <= value::size_, "insufficient space");

    static void assign (value&, vector<T>&&);
    static void append (value&, vector<T>&&);
    static void prepend (value&, vector<T>&&);
    static bool empty (const vector<T>& x) {return x.empty ();}

    static const string type_name;
    static const build2::value_type value_type;
  };

  // map<K, V>
  //
  template <typename K, typename V>
  struct value_traits<std::map<K, V>>
  {
    template <typename K1, typename V1> using map = std::map<K1, V1>;

    static_assert (sizeof (map<K, V>) <= value::size_, "insufficient space");

    static void assign (value&, map<K, V>&&);
    static void append (value&, map<K, V>&&);
    static void prepend (value& v, map<K, V>&& x) {
      return append (v, move (x));}
    static bool empty (const map<K, V>& x) {return x.empty ();}

    static const string type_name;
    static const build2::value_type value_type;
  };
}

// Variable map.
//
namespace std
{
  template <>
  struct hash<build2::variable>: hash<string>
  {
    size_t
    operator() (const build2::variable& v) const noexcept
    {
      return hash<string>::operator() (v.name);
    }
  };
}

namespace butl
{
  template <>
  struct compare_prefix<std::reference_wrapper<const build2::variable>>:
    compare_prefix<std::string>
  {
    typedef compare_prefix<std::string> base;

    explicit
    compare_prefix (char d): base (d) {}

    bool
    operator() (const build2::variable& x, const build2::variable& y) const
    {
      return base::operator() (x.name, y.name);
    }

    bool
    prefix (const build2::variable& p, const build2::variable& k) const
    {
      return base::prefix (p.name, k.name);
    }
  };
}

namespace build2
{
  // variable_pool
  //
  using variable_pool_base = std::unordered_set<variable>;
  struct variable_pool: private variable_pool_base
  {
    const variable&
    insert (string name,
            bool overridable = false,
            variable_visibility v = variable_visibility::normal)
    {
      return insert (move (name), nullptr, v, overridable);
    }

    template <typename T>
    const variable&
    insert (string name,
            bool overridable = false,
            variable_visibility v = variable_visibility::normal)
    {
      return insert (
        move (name), &value_traits<T>::value_type, v, overridable);
    }

    const variable&
    find (const string& name); //@@ TODO: Move to operator[], remove.
                               //@@ ranmae var_pool to varpool or vpool?

    const variable&
    operator[] (const string& name) {return find (name);}

    using variable_pool_base::clear;

  private:
    const variable&
    insert (string name,
            const build2::value_type*,
            variable_visibility,
            bool overridable);
  };

  extern variable_pool var_pool;

  // variable_map
  //
  class variable_map
  {
  public:
    using map_type = butl::prefix_map<reference_wrapper<const variable>,
                                      value,
                                      '.'>;
    using size_type = map_type::size_type;

    template <typename I>
    struct iterator_adapter: I
    {
      iterator_adapter () = default;
      iterator_adapter (const I& i): I (i) {}

      // Automatically type a newly typed value on access.
      //
      typename I::reference operator* () const;
      typename I::pointer operator-> () const;

      // Untyped access.
      //
      uint16_t extra () const {return I::operator* ().second.extra;}
      typename I::reference untyped () const {return I::operator* ();}
    };

    using const_iterator = iterator_adapter<map_type::const_iterator>;

    // Lookup. Note that variable overrides will not be applied, even if
    // set in this map.
    //
    lookup
    operator[] (const variable& var) const
    {
      return lookup (find (var), this);
    }

    lookup
    operator[] (const string& name) const
    {
      return operator[] (var_pool.find (name));
    }

    // If typed is false, leave the value untyped even if the variable is.
    //
    const value*
    find (const variable&, bool typed = true) const;

    value*
    find (const variable&, bool typed = true);

    // Return a value suitable for assignment. See scope for details.
    //
    value&
    assign (const variable& var) {return insert (var).first;}

    value&
    assign (const string& name) {return insert (name).first;}

    // Unlike the two above, assign a typed, non-overridable variable with
    // normal visibility.
    //
    template <typename T>
    value&
    assign (string name)
    {
      return assign (var_pool.insert<T> (move (name)));
    }

    // As above but also return an indication of whether the new value (which
    // will be NULL) was actually inserted. Similar to find(), if typed is
    // false, leave the value untyped even if the variable is.
    //
    pair<reference_wrapper<value>, bool>
    insert (const variable&, bool typed = true);

    pair<reference_wrapper<value>, bool>
    insert (const string& name, bool typed = true)
    {
      return insert (var_pool.find (name), typed);
    }

    pair<const_iterator, const_iterator>
    find_namespace (const string& ns) const
    {
      auto r (m_.find_prefix (var_pool.find (ns)));
      return make_pair (const_iterator (r.first), const_iterator (r.second));
    }

    const_iterator
    begin () const {return m_.begin ();}

    const_iterator
    end () const {return m_.end ();}

    bool
    empty () const {return m_.empty ();}

    size_type
    size () const {return m_.size ();}

  private:
    map_type m_;
  };

  // Target type/pattern-specific variables.
  //
  using variable_pattern_map = std::map<string, variable_map>;
  using variable_type_map_base = std::map<reference_wrapper<const target_type>,
                                          variable_pattern_map>;

  struct variable_type_map: variable_type_map_base
  {
    lookup
    find (const target_type&, const string& tname, const variable&) const;

    // In many places we assume that we can store a reference to the returned
    // variable value (e.g., install::lookup_install()). As a result, in case
    // of append/prepent where we calculate the value dynamically, we have to
    // cache it.
    //
    // The key is the combination of the "original value idenity" (as a
    // pointer to the value in variable_pattern_map) and the "target identity"
    // (as target type and target name). The target name, unfortunately, has
    // to be stored by value (maybe will pool them at some point).
    //
    mutable
    std::map<tuple<const value*, const target_type*, string>, value> cache;
  };

  // Override cache.
  //
  struct variable_override_value
  {
    build2::value value;
    const variable_map* stem_vars = nullptr; // NULL means there is no stem.
  };

  extern std::map<pair<const variable_map*, const variable*>,
                  variable_override_value> variable_override_cache;
}

#include <build2/variable.ixx>
#include <build2/variable.txx>

#endif // BUILD2_VARIABLE
