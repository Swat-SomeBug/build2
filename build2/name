// file      : build2/name -*- C++ -*-
// copyright : Copyright (c) 2014-2016 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

// Note: include <build2/types> instead of this file directly.
//

#ifndef BUILD2_NAME
#define BUILD2_NAME

// We cannot include <build2/utility> since it includes <build2/types>.
//
#include <utility> // move()

namespace build2
{
  using std::move;

  // A name is what we operate on by default. Depending on the context,
  // it can be interpreted as a target or prerequisite name. A name
  // without a type and directory can be used to represent any text.
  // A name with directory and empty value represents a directory.
  // A name may also be project-qualified. If the project name is
  // empty, then it means the name is in a project other than our
  // own (e.g., it is installed).
  //
  // If pair is not '\0', then this name and the next in the list
  // form a pair.
  //
  struct name
  {
    const string* proj = nullptr; // Points to project_name_pool.
    dir_path dir;
    string type;
    string value;
    char pair = '\0'; // Pair character if first half of a pair. Can be used
                      // as bool.

    name () = default;

    explicit name (string v): value (move (v)) {}
    name& operator= (string v) {return *this = name (move (v));}

    explicit name (dir_path d): dir (move (d)) {}
    name& operator= (dir_path d) {return *this = name (move (d));}

    name (string t, string v): type (move (t)), value (move (v)) {}

    name (dir_path d, string t, string v)
        : dir (move (d)), type (move (t)), value (move (v)) {}

    // The first argument should be from project_name_pool.
    //
    name (const string* p, dir_path d, string t, string v)
        : proj (p), dir (move (d)), type (move (t)), value (move (v)) {}

    bool
    qualified () const {return proj != nullptr;}

    bool
    unqualified () const {return proj == nullptr;}

    bool
    typed () const {return !type.empty ();}

    bool
    untyped () const {return type.empty ();}

    bool
    empty () const {return dir.empty () && value.empty ();}

    // Note that strictly speaking the following tests should be orthogonal
    // to qualification. However, the vast majority of cases where we expect
    // a simple or directory name, we also expect it to be unqualified.
    //
    // Note also that empty name is simple but not a directory.
    //
    bool
    simple (bool ignore_qual = false) const
    {
      return (ignore_qual || unqualified ()) && untyped () && dir.empty ();
    }

    bool
    directory (bool ignore_qual = false) const
    {
      return (ignore_qual || unqualified ()) &&
        untyped () && !dir.empty () && value.empty ();
    }

    int
    compare (const name&) const;

    // The result is an unqualified, simple empty name.
    //
    void
    clear ();
  };

  inline bool
  operator== (const name& x, const name& y) {return x.compare (y) == 0;}

  inline bool
  operator!= (const name& x, const name& y) {return !(x == y);}

  inline bool
  operator< (const name& x, const name& y) {return x.compare (y) < 0;}

  ostream&
  operator<< (ostream&, const name&);

  // Vector of names.
  //
  using names = vector<name>;
  using names_view = vector_view<const name>;

  ostream&
  operator<< (ostream&, const names_view&);

  inline ostream&
  operator<< (ostream& os, const names& n) {return os << names_view (n);}
}

#include <build2/name.ixx>

#endif // BUILD2_NAME
